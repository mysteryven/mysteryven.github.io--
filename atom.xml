<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MysteryZZZ&#39;s Blog</title>
  
  <subtitle>none</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mysterywz.xyz/"/>
  <updated>2019-11-05T02:29:17.017Z</updated>
  <id>http://mysterywz.xyz/</id>
  
  <author>
    <name>wz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>generator 模拟 async/await 语法</title>
    <link href="http://mysterywz.xyz/passages/generator-mock-async/"/>
    <id>http://mysterywz.xyz/passages/generator-mock-async/</id>
    <published>2019-11-05T02:07:36.000Z</published>
    <updated>2019-11-05T02:29:17.017Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们有一个 ajax 请求：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'hello world'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果用 <code>async/await</code> 来写，可以很方便的写成下面这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> doTask();</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们怎么使用迭代器的语法写出来呢？</p><p>接下来我们需要一个 runner 函数来运行它，这是最主要的：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runner</span>(<span class="params">genFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> itr = genFn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = itr.next(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.value</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve.(result.value).then(run);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> doTask();</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runner(init); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></p><p>我之前一直不理解为什么 <code>const res = yield doTask()</code> 为什么能拿到返回值，后来才注意到放到 <code>itr.next</code> 的参数。yield 的返回值就是前一步的 next 括号里面的值。</p><p><a href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们有一个 ajax 请求：
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>简谈web性能优化</title>
    <link href="http://mysterywz.xyz/passages/%E7%AE%80%E8%B0%88web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://mysterywz.xyz/passages/简谈web性能优化/</id>
    <published>2019-03-18T13:01:55.000Z</published>
    <updated>2019-10-31T05:41:17.398Z</updated>
    
    <content type="html"><![CDATA[<p>前几天去面试，面试官全程围绕 web 性能优化的主题展开，问的我是一头雾水。由于没回答上几道题，结果自然也可想而知。</p><p>我回来之后赶紧查一下资料，发现这里面的坑，还真的蛮大的，下面我就来介绍一下。</p><p>当我们访问一个网址的时候，大概有以下几个过程：</p><ol><li>查看是否有缓存</li><li>通过 DNS 来查到域名对应的 IP 地址</li><li>建立 TCP 连接</li><li>发送 HTTP 请求</li><li>请求到 HTML 后再根据页面里具体的请求来请求 CSS、IMG、JS 文件</li></ol><p>如果想要优化，也肯定是在这几个步骤上面想办法。</p><p>如果我们想优化第 2 步，可以通过减少不同的域名请求来达到减少 DNS 查询的目的。</p><p>优化 TCP 连接可以开启连接复用（添加请求头 <code>keep-alive</code>)。</p><p>优化 HTTP 请求方面，我们不要滥用 cookie，已减小请求体积；也可以使用 <code>cache-control</code> 、<code>Expires</code> 等缓存机制，也可以同时发送多个请求（注意，一个域名有请求发送限制，此时可以通过增加域名的方式来解决）响应 HTTP 请求可以通过 <code>ETag</code> 的方式响应 304，这样就减少响应第四部分的体积了，当然了，也可以对请求的第四部分使用 gzip 的方式压缩。</p><p>但是我们增加域名了之后也会增加 DNS 请求的负担，这就矛盾了，对此情况我们要具体情况具体分析了。一般来说，如果用户带宽足够，文件很多就增加域名，文件很少就尽量减少域名了。</p><p>对于请求 HTML ，我们最好在文件开头就指定 <code>DOCTYPE</code> , 这样就不用浏览器去判断文档类型了。</p><p>请求 css 、js 、 img 之类的文件呢？一个优化策略就是使用 CDN（内容分发网络），它能加速请求的响应，也能增加同时下载数（下载可以同步，解析不同步）。</p><p>ps: CDN 是把内容分发到各地，使各地的人访问都能较快</p><p>另外一个策略就是我们组织文件的方式来，这个我在面试中被问到了。由于解析 css 会重新渲染 DOM 树（在 chrome 中 css 放在后面会阻塞渲染），所以我们必须把 css 放在 <code>head</code> 里面，让 css 尽早下载，既不让用户看到残缺页面，也能优化我们的页面。</p><p>由于 js 只能一个个的解析，并在解析的同时会阻塞解析 HTML 下面的页面，所以我们要把 js 放在后面，这样能让 js 取到所有的 dom 节点，也能让用户看到完整的网页。</p><p>对于优化 img 的话，我们可以使用懒加载的方式，也就是等用户快要看到的时候加载。</p><p>好了，优化策略写到这就写完了，希望对你有帮助。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天去面试，面试官全程围绕 web 性能优化的主题展开，问的我是一头雾水。由于没回答上几道题，结果自然也可想而知。&lt;/p&gt;
&lt;p&gt;我回来之后赶紧查一下资料，发现这里面的坑，还真的蛮大的，下面我就来介绍一下。&lt;/p&gt;
&lt;p&gt;当我们访问一个网址的时候，大概有以下几个过程：&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>继承的两种写法</title>
    <link href="http://mysterywz.xyz/passages/js%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%99%E6%B3%95/"/>
    <id>http://mysterywz.xyz/passages/js继承的写法/</id>
    <published>2019-03-18T12:39:16.000Z</published>
    <updated>2019-10-31T05:41:17.369Z</updated>
    
    <content type="html"><![CDATA[<p>前几天去面试的时候被问到了这个问题，今天来重新整理一下，并比较一下二者的区别。</p><p>如果使用 ES5 ，写起来还挺麻烦的。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.run = function() &#123;</span><br><span class="line">  console.log(&apos;Hi, I am &apos; + this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog() &#123;</span><br><span class="line">  Animal.apply(this, arguments)</span><br><span class="line">  this.age = 12</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f = function()&#123;&#125;</span><br><span class="line">f.prototype = Animal.prototype</span><br><span class="line">Dog.prototype = new f()</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&apos;xxx&apos;)</span><br><span class="line">dog.run()</span><br></pre></td></tr></table></figure></p><p>如果使用 ES6 的 Class 语法，就简单多了。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    console.log(&apos;Hi, I am &apos; + this.name) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    super(name)</span><br><span class="line">    this.age = 12</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&apos;xxx&apos;)</span><br><span class="line">dog.run()</span><br></pre></td></tr></table></figure></p><p>上面实现的效果完全相同。</p><p>其实 class 只是一个语法糖而已，它能实现前一种写法一样的功能。可能你会想，既然 class 的写法简单并也没什么不能做的，那我只学 class 就好了，还学原型的写法干什么？其实两种写法都有优劣。首先，只学 class 并不能了解继承的本质，另外，在某些情况下，class 并不简便。</p><p>比如，我们想给 Animal 的原型上面添加一个字段而不是方法，用 ES5 我们只需要写 <code>Animal.prototype.xxx = 'yyy'</code> 即可，但是在 class 那种写法就要麻烦一点了。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get xxx() &#123;</span><br><span class="line">  return &apos;yyy&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很多相对立的东西都可以采用「二元论」的策略去认识。大的如同 Vue 和 React，小的如同 JS 继承的两种写法，它可以让我们快速抓住事物的本质并快速的学会。我想很多人都会这么学吧。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天去面试的时候被问到了这个问题，今天来重新整理一下，并比较一下二者的区别。&lt;/p&gt;
&lt;p&gt;如果使用 ES5 ，写起来还挺麻烦的。&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>手写bind</title>
    <link href="http://mysterywz.xyz/passages/%E6%89%8B%E5%86%99bind/"/>
    <id>http://mysterywz.xyz/passages/手写bind/</id>
    <published>2019-03-06T01:42:15.000Z</published>
    <updated>2019-10-31T05:41:17.395Z</updated>
    
    <content type="html"><![CDATA[<p>bind 是在 ES5 新加入的语法，具体的语法 MDN 都有。但有一点需要额外注意一下：bind 会返回一个新的函数。也就是说：它会修改 this 的指向，并返回新的函数体。</p><p>接下来，我来讲一下手写 bind 的思路。</p><p>首先我们要明白 bind 的用途：它是为了改变默认 this 的，如：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yyy</span>(<span class="params">a</span>) </span>&#123;<span class="keyword">this</span>.a = a&#125;</span><br><span class="line"><span class="keyword">var</span> xxx = yyy.bind(obj)</span><br><span class="line">xxx(a) = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>此时 xxx 的代码实际上是下面这样的</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">newA</span>) </span>&#123;</span><br><span class="line">   obj.a = newA </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解了如何使用，我们才能往下写，我们来为函数的原型添加一个 <code>myBind</code> 方法</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">otherThis</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前的 this 是 yyy，如果 this 的类型不是函数，就返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 yyy 除去第一项后的参数，也就是除去 this 的剩余参数</span></span><br><span class="line">  <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) </span><br><span class="line">  <span class="keyword">var</span> bindArgsLength = bindArgs.length  <span class="comment">// 这句话很重要，代码后有解释</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBind = <span class="keyword">this</span> <span class="comment">// yyy ，也是要绑定到哪里</span></span><br><span class="line">  <span class="keyword">var</span> fNP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">// 中间量，以便生成的 xxx 和原来函数毫无瓜葛</span></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bindArgs.length = bindArgsLength <span class="comment">// 必须重置 bindArgs 的长度</span></span><br><span class="line">    bindArgs.push.apply(bindArgs, <span class="built_in">arguments</span>) <span class="comment">// 组合两次的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBind.apply(otherThis, bindArgs) <span class="comment">// 用 apply 方法为新的返回值绑定用户指定的 this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123; <span class="comment">// Function.prototype 没有 prototype</span></span><br><span class="line">    fNP.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNP() </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>需要说明一下重置 bindArgs 那一句话：</p><p>因为 bindArgs 是和 fBound 同一级别的，当执行 <code>myBind</code> 这个函数之后，fBound 和 bindArgs 都只有一份，但是可能多次调用 myBind 返回的函数（这里是 xxx）并传参，如果不重置，我们两次调用 xxx('aaa')，那 bindArgs 的长度就变为 2 了，但我们希望两次调用不能被影响，只能受父亲 yyy 传参的影响。由于每次添加都是 push 到后面，所有每次只要恢复成以前的长度即可。</p><p>好了，我们已经大致完成了，但是还要一个缺陷：不支持 new，真正的 bind 方法在使用 new 之后的 this 还是指向 new 新生成的对象。</p><p>举例来说，我们希望得到下面的效果：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yyy</span>(<span class="params">a</span>) </span>&#123;<span class="keyword">this</span>.a = a&#125;</span><br><span class="line"><span class="keyword">var</span> xxx = yyy.bind(obj)</span><br><span class="line"><span class="keyword">var</span> xxxxxx = <span class="keyword">new</span> xxx(<span class="string">'你好'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">console</span>.log(xxxxxx.a) <span class="comment">// 你好</span></span><br></pre></td></tr></table></figure></p><p>而我们现在的代码是如何的呢？ 由于我们没做判断，我们返回的函数实际是：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xxx</span>(<span class="params">newA</span>) </span>&#123;</span><br><span class="line">   obj.a = newA </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：xxxxxx.a 未定义，而 obj.a 是你好</p><p>如何解决？只需在执行 apply 的时候绑定更换绑定的 this 就好了解决的关键是 this 到底指向什么，如果使用 new 操作符，那个时候的 this 就是指向新的对象。</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">otherThis</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前的 this 是 yyy，如何 this 的类型不是函数，就返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) <span class="comment">// 获取 yyy 除去第一项后的参数</span></span><br><span class="line">  <span class="keyword">var</span> bindArgsLength = bindArgs.length </span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBind = <span class="keyword">this</span> <span class="comment">// yyy ，也是是要绑定到哪里</span></span><br><span class="line">  <span class="keyword">var</span> fNP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">// 中间量，以便生成的 xxx 和原来函数毫无瓜葛</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123; <span class="comment">// Function.prototype 没有 prototype</span></span><br><span class="line">    fNP.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  &#125; <span class="comment">// 放在前面便于理解</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bindArgs.length = bindArgsLength <span class="comment">// 必须重置 bindArgs 的长度</span></span><br><span class="line">    bindArgs.push.apply(bindArgs, <span class="built_in">arguments</span>) <span class="comment">// 组合两次的数据</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果使用 new 操作符，此时 this 指向的是新生成的对象，那么 fNP.prototype.isPrototypeOf(this) === true</span></span><br><span class="line">      <span class="comment">// xxxxxx -&gt; xxx -&gt; FNP</span></span><br><span class="line">      <span class="keyword">return</span> fBind.apply( fNP.prototype.isPrototypeOf(<span class="keyword">this</span>) ? <span class="keyword">this</span>: otherThis, bindArgs) </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNP() </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>写完了，昨天花了一个下午的时间在理解这个问题，我认为理解起来还是有点难度的，希望帮助到你。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;bind 是在 ES5 新加入的语法，具体的语法 MDN 都有。但有一点需要额外注意一下：bind 会返回一个新的函数。也就是说：它会修改 this 的指向，并返回新的函数体。&lt;/p&gt;
&lt;p&gt;接下来，我来讲一下手写 bind 的思路。&lt;/p&gt;
&lt;p&gt;首先我们要明白 bind
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js里面new到底有什么用？</title>
    <link href="http://mysterywz.xyz/passages/js%E9%87%8C%E9%9D%A2new%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F/"/>
    <id>http://mysterywz.xyz/passages/js里面new到底有什么用？/</id>
    <published>2019-03-01T07:34:41.000Z</published>
    <updated>2019-10-31T05:41:17.371Z</updated>
    
    <content type="html"><![CDATA[<p>最近要准备面试了，于是拿起以前的知识点复习一下，今天看到了一片博文讲 <code>new</code> 讲的非常不错，于是我再简略的概括一下亦当复习了。</p><p>首先要明白，<code>new</code>其实是一个语法糖。</p><p>如果我们创建了一个构造函数叫 <code>Food</code>，当我们执行 <code>new Food</code> 的时候会发生什么呢？</p><ol><li>js 帮我们在 <code>Food</code> 内部声明一个临时的空对象</li><li>把 <code>Food</code> 里面 this 指向的属性或者方法都放到临时对象里面</li><li>让临时对象的一个叫做 <code>_proto</code> 的属性指向 <code>Food</code> 的 <code>prototype</code></li><li>返回这个临时对象</li></ol><p>当然了，我们也可以不用 <code>new</code> 操作符，如果不怕麻烦的话。</p><p>另外的，一个新的对象都有一个 <code>constructor</code> 属性，作用是为了指名构造它的是哪一个对象。它不会自动修改。</p><p>在构造对象的时候如果我们使用下面的方式修改原型</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Food.prototype = &#123;</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样之后，<code>prototype</code> 的指向就完全变了，那 <code>constructor</code> 也就变了，此时我们还需要手动改回来，在 <code>Food.prototype</code> 添加 <code>constructor</code> 属性，或者不让 <code>Food.prototype</code> 是一个新对象，直接如下方式修改：</p><pre><code>Food.prototype.toString = ...</code></pre><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要准备面试了，于是拿起以前的知识点复习一下，今天看到了一片博文讲 &lt;code&gt;new&lt;/code&gt; 讲的非常不错，于是我再简略的概括一下亦当复习了。&lt;/p&gt;
&lt;p&gt;首先要明白，&lt;code&gt;new&lt;/code&gt;其实是一个语法糖。&lt;/p&gt;
&lt;p&gt;如果我们创建了一个构造函数叫
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>单元测试的必要性</title>
    <link href="http://mysterywz.xyz/passages/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
    <id>http://mysterywz.xyz/passages/单元测试的必要性/</id>
    <published>2019-02-16T11:06:41.000Z</published>
    <updated>2019-10-31T05:41:17.383Z</updated>
    
    <content type="html"><![CDATA[<p>我本来没有听过「单元测试」，更别提意识到单元测试的重要性了。最近在写组件库的时候，了解到了这方面的知识，并写了几个单元测试，发现它确实是必不可少的一环，它不仅让你对自己的代码更自信，还能让别人更信任你的代码，你以为只有这些吗？当然不是，它还能让你的代码更健康的迭代。总之，单元测试是所有软件工程师必须要做的。</p><p>你可能会疑问，有了测试人员，我写单元测试还有必要吗？当然有必要，因为单元测试只是测试中的一小部分。</p><p>测试按照种类可以大致分为两类，黑盒测试和白盒测试。按照规模由大到小可以分为：单元测试，模块测试，功能测试，集成测试</p><p>什么是黑盒测试？有一个例子就是测试人员测试，他们不懂我们的代码，通常会进行一些边界情况的测试。而我们的单元测试就是白盒测试，单元测试是很有必要的，虽然我们写代码的时候很成功，但是不能保证以后的代码对现在的代码有没有影响，我总不能写完一个组件，把之前的全部组件再手动测一次吧？</p><p>目前，很多人没意识到单元测试的重要性，其实也不是咱们懒，是有很多客观原因摆着的。由于现在前端还处于发展的阶段，框架的还没有稳固呢，这不，vue 3 要发布了，所以很多人都在忙着学习框架的知识，测试先放一会吧。并且我们现在的开发现状也不允许我们写测试，哪有时间呀？今天提的需求，明天可能就要上线了，能用就不错了！</p><p>结合其他语言的发展历程，这一块肯定是要被重视起来的。写代码还需要测试虽然麻烦，但是好处大大的有。</p><p>当然了，如果你实在不喜欢单元测试，也不必慌，不是所有的代码都需要单元测试。</p><p>比如一般的不可复用的业务代码，根本不需要单元测试，如果你公司里的登录、注册、订单类的流程基本一致，那就可以把公用的代码抽离出来，做成组件，并给它们添加单元测试，这是必要的。</p><p>还有就是自己造的组件库，比如我目前就是在写一个组件库。很坑，其实我写这篇文章不仅仅是为了总结这一块的知识，我也在说服我自己写测试...好吧，写到这里，我相信我自己也信服了，乖乖写测试去咯，争取覆盖率 95% 以上 ！</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我本来没有听过「单元测试」，更别提意识到单元测试的重要性了。最近在写组件库的时候，了解到了这方面的知识，并写了几个单元测试，发现它确实是必不可少的一环，它不仅让你对自己的代码更自信，还能让别人更信任你的代码，你以为只有这些吗？当然不是，它还能让你的代码更健康的迭代。总之，单
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自建一个文件上传的小demo（前后台）</title>
    <link href="http://mysterywz.xyz/passages/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%EF%BC%88%E5%89%8D%E5%90%8E%E5%8F%B0%EF%BC%89/"/>
    <id>http://mysterywz.xyz/passages/实现一个简单的图片上传功能（前后台）/</id>
    <published>2019-02-10T13:35:56.000Z</published>
    <updated>2019-10-31T05:41:17.388Z</updated>
    
    <content type="html"><![CDATA[<p>最近计划做一个图片上传的组件，在前期准备工作中就遇到了一些困难，比如：如何用 ajax 发送 form 表单的数据，如何把发送过去的数据存到服务器，现在，我已经解决了这些问题，基本实现了图片上传的原理，下面就是对应的代码。</p><p>如何去使用呢？</p><ol><li>先把第一部分的 html 代码拷贝到本地，用 server 打开，或者直接拷贝到 JSbin 此类的在线编辑器也行。</li><li>拷贝第二部分的 Node.js 的代码，安装所需要的依赖（express, multer），之后运行它。</li><li>在你的 html 代码部分点击上传吧，看看控制的的 network 有什么反应，然后再去你的 Node.js 端看一下是否多了一个 uploads 目录呢？如果是，恭喜你，成功了！</li><li>如果有任何问题，欢迎联系我，联系方式看 「关于」。</li></ol><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"img"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span></span><br><span class="line"><span class="javascript">    input.addEventListener(<span class="string">'change'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">       formData.append(<span class="string">'img'</span>, input.files[<span class="number">0</span>])</span></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'POST'</span>, <span class="string">'http:127.0.0.1:3000/upload'</span>)</span></span><br><span class="line"><span class="javascript">    xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'success'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    xhr.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined">    xhr.send(formData)</span></span><br><span class="line"><span class="undefined">      </span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const express = require(&apos;express&apos;) </span><br><span class="line">const multer  = require(&apos;multer&apos;)</span><br><span class="line">const upload = multer(&#123; dest: &apos;uploads/&apos; &#125;)</span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line">// img 的名称需要和 formData 的数据的 key 相匹配</span><br><span class="line">app.post(&apos;/upload&apos;, upload.single(&apos;img&apos;), function(req, res) &#123;</span><br><span class="line">   res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置跨域</span><br><span class="line">   res.send(&apos;我收到了你的文件，并存到了 uploads目录&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&apos;开始监听了&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>由于是个简单的 demo，就没有继续添加图片预览的功能了，后续我会在我的组件库中加入这个，如果你感兴趣，欢迎联系我。</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近计划做一个图片上传的组件，在前期准备工作中就遇到了一些困难，比如：如何用 ajax 发送 form 表单的数据，如何把发送过去的数据存到服务器，现在，我已经解决了这些问题，基本实现了图片上传的原理，下面就是对应的代码。&lt;/p&gt;
&lt;p&gt;如何去使用呢？&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>小程序的几个坑</title>
    <link href="http://mysterywz.xyz/passages/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91/"/>
    <id>http://mysterywz.xyz/passages/小程序的几个坑/</id>
    <published>2019-01-30T15:13:05.000Z</published>
    <updated>2019-10-31T05:41:17.392Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>小程序的底部栏或者顶部栏要用 cover-view 标签，以防页面中有 map 等元素浮到它的上面</p></li><li><p>双层循环如此写：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;lists&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">    &lt;view wx:for="</span>&#123;&#123;<span class="attr">lists.goods</span>&#125;&#125;" <span class="attr">wx:for-item</span>=<span class="string">"good-item"</span> <span class="attr">wx:for-index</span>=<span class="string">"good-index"</span>&gt;</span></span><br><span class="line">          &#123;&#123;good-item&#125;&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li><li><p>跳转 tab 页面只能 switchTab，这个好好注意一下</p></li><li><p>canvas 显示网络中的图片</p></li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getImg(id).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> imgPath = res.xxx <span class="comment">// 你的图片路径</span></span><br><span class="line"></span><br><span class="line">    wx.getImageInfo(&#123;</span><br><span class="line">          src: imgPath,</span><br><span class="line">            success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> content = wx.createCanvasContext(<span class="string">'myCanvas'</span>)</span><br><span class="line">              content.drawImage(imgPath, <span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">100</span>)</span><br><span class="line">              content.draw()</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>getImg 是代表异步获取图片链接的代码，小程序比较蛋疼的就是无法把网络地址的图片直接展示在画布上，所以需要我们先获取到图片，再用小程序的方法获取图片的临时链接，最后把临时链接画到画布上。</p><ol start="5"><li>canvas 使用 rpx</li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.getSystemInfo(&#123;</span><br><span class="line">  success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        rpx: res.windowWidth / <span class="number">375</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>小程序的画布是不支持 rpx 的，这一点也很烦，所以需要我们手动写好 rpx 的函数，然后在需要使用单位的地方使用 rpx 得到返回值来使用。</p><p>（完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小程序的底部栏或者顶部栏要用 cover-view 标签，以防页面中有 map 等元素浮到它的上面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双层循环如此写：
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轮播组件和vue结合的一次bug</title>
    <link href="http://mysterywz.xyz/passages/%20vue%E7%9A%84mounted%E5%BC%95%E5%8F%91%E7%9A%84bug/"/>
    <id>http://mysterywz.xyz/passages/ vue的mounted引发的bug/</id>
    <published>2018-12-06T11:55:09.000Z</published>
    <updated>2019-10-31T05:41:17.351Z</updated>
    
    <content type="html"><![CDATA[<p>这几天我在做vue项目的时候遇到了一个坑，导致我上个周六就没好好做项目，一直到今天才得以解决。</p><p>是这样的，我在渲染轮播图的时候，一直出现加载到了数据但是无法滑动的情况，当我换成静态的数据就有办法滑动了，这让我很费解。后来我询问了一个朋友，他帮我解决了，原因如下：</p><p>我在还没获取完数据就把轮播初始化了。</p><p>额，对就是这么简单，我把轮播放到 mounted 里面了，尽管我是在 created 的生命周期里请求的数据，但是当所有的dom节点都加载完成了，数据还没请求完毕，而这时候轮播已经初始化了。知道这个原因之后，我把初始化轮播的操作放到请求完数据的 nexttick ，然后就成功了！</p><p>我去，这是我学习 vue 第一个大坑啊！解决完真开心。</p><p>以前都没用过 nexttick ，这次也算是用的恰到好处。</p><p>以上（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天我在做vue项目的时候遇到了一个坑，导致我上个周六就没好好做项目，一直到今天才得以解决。&lt;/p&gt;
&lt;p&gt;是这样的，我在渲染轮播图的时候，一直出现加载到了数据但是无法滑动的情况，当我换成静态的数据就有办法滑动了，这让我很费解。后来我询问了一个朋友，他帮我解决了，原因如下
      
    
    </summary>
    
    
      <category term="vue" scheme="http://mysterywz.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>表单美化小技巧</title>
    <link href="http://mysterywz.xyz/passages/css%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E5%8D%95%E7%BE%8E%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>http://mysterywz.xyz/passages/css笔记之表单美化技巧/</id>
    <published>2018-12-02T00:50:43.000Z</published>
    <updated>2019-10-31T05:41:17.363Z</updated>
    
    <content type="html"><![CDATA[<h2>去掉本身的 outline</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input[type=text]:focus &#123;</span><br><span class="line">  outline: none;</span><br><span class="line">  border-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不要定 input 的宽高，用 padding 的形式做出来可以通过调节 font-size 来调节光标的大小高度和行高一样就是居中的input 会有自动补全功能, autocomplete=&quot;off&quot; 可以关掉他</p><p>上传文件后立马上传，要监听 input 的 onchange<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// search jquery get formData</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">formData.append(<span class="string">'file'</span>, input.files[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">ajax.....</span><br></pre></td></tr></table></figure></p><p>button 会自动上下居中，如果不是的话且文字只有一行可以用 line-height == height 来使它居中做动画用 visibility 属性`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;去掉本身的 outline&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="css" scheme="http://mysterywz.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>BFC的作用</title>
    <link href="http://mysterywz.xyz/passages/css%E7%AC%94%E8%AE%B0%E4%B9%8BBFC/"/>
    <id>http://mysterywz.xyz/passages/css笔记之BFC/</id>
    <published>2018-12-01T12:51:07.000Z</published>
    <updated>2019-10-31T05:41:17.358Z</updated>
    
    <content type="html"><![CDATA[<p>Block formatting content</p><p>如何创建 BFC ?</p><p>父元素 float、absolute、inline-block、overflow 不为 visiblediplay: table-cell、flow-root 等display: flow-root 只有一个触发 BFC 的功能</p><p>它可以把内部的元素都包起来，也可以和同级的其他元素划清界限最好不要用 BFC 来清除浮动，会有副作用</p><p>BFC 实在不常用，我只用到过一次，比较实用的一个功能就是可以去掉父子元素的 margin 合并，但是由于除了 flow-root ，其他属性都有未知的副作用，而flow-root浏览器的支持不太好。所以还是不要用的好，解决 margin 合并的话可以用 padding、border 来挡住。</p><p>总结一下，BFC 完全可以不使用！</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Block formatting content&lt;/p&gt;
&lt;p&gt;如何创建 BFC ?&lt;/p&gt;
&lt;p&gt;父元素 float、absolute、inline-block、overflow 不为 visible
diplay: table-cell、flow-root 等
disp
      
    
    </summary>
    
    
      <category term="css" scheme="http://mysterywz.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>移动端页面布局的几点注意事项</title>
    <link href="http://mysterywz.xyz/passages/css%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://mysterywz.xyz/passages/css笔记之移动端页面布局/</id>
    <published>2018-12-01T11:04:15.000Z</published>
    <updated>2019-10-31T05:41:17.362Z</updated>
    
    <content type="html"><![CDATA[<h2>媒体查询</h2><p>语法如下:<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> (min-width: <span class="number">400px</span>) and (max-width: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;link rel="stylesheet" href="./style.css" media="(min-width: 600px) and (max-width: 900px)"&gt;</span><br></pre></td></tr></table></figure></p><p>有个新闻网站很好的实现了响应式布局: <a href="https://www.smashingmagazine.com/articles/" target="_blank" rel="noopener">smashingmagazine</a>响应式的本质其实就是做多版，通过媒体查询来选择哪一个</p><h2>meta 中 viewport 属性</h2><p><code>html &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p><p>如果 html 文件里面不加上面那句话，那在手机端的页面宽度就会伪造成 980px，然后根据手机的宽度等比例的把页面宽度缩小。比如 iphone6 的宽度为 375px，那访问同一个页面一个元素的大小变为原来的 375/980。</p><h2>移动端与 pc 的不同</h2><p>没有 hover没有 resize没有滚动条有  touch没有 IE 浏览器！！！</p><h2>flex 布局</h2><p>有一篇非常好的博客 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">flex布局</a></p><h2>手机端布局的注意事项</h2><p>一个小的知识点，给一个没有宽度的块级元素加负 margin，会让他的宽高撑出去。pc 有滚动条的原因是有宽度，为了避免，要用 width autocalc属性可以多用一下，比如 <code>width: (25% -8px)</code>, 接着设置他们的 margin 为 8，这样不管怎么变，两个元素都是 8px的间距</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;媒体查询&lt;/h2&gt;
&lt;p&gt;语法如下:
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa
      
    
    </summary>
    
    
      <category term="css" scheme="http://mysterywz.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>页面引入图片的几种方式</title>
    <link href="http://mysterywz.xyz/passages/css%E7%AC%94%E8%AE%B0%E4%B9%8Bicon/"/>
    <id>http://mysterywz.xyz/passages/css笔记之icon/</id>
    <published>2018-12-01T08:00:56.000Z</published>
    <updated>2019-10-31T05:41:17.360Z</updated>
    
    <content type="html"><![CDATA[<h2>tips</h2><p>图片不要同时写宽和高，只要写了宽这一个属性，他会按照以前图片的比例自适应宽高的。</p><h2>ps 导出单一图标</h2><p>如果设计师给你一张大的 PSD 格式的图片，可以按照以下步骤导出单个图标:选中图层 -&gt; depulicate layer(选择 new) -&gt; (image-trim)后续可以在 PS 调整 image 的 size</p><blockquote><p>下面讲述页面引入 icon 的几种方法。</p></blockquote><h2>img</h2><p>优点是可以自适应宽高比例，写起来也很简单。</p><h2>background</h2><p>设置 inline-block, width, height 即可</p><h2>css sprites</h2><p>网上搜索 「css sprites generator」即可，但是我以前都没听过。</p><h2>iconfont</h2><p>它的原理是把字体设计成图标，比如一个字体的编码 &amp;111，它来表示 A，现在字体设计师为了表示一个微信图标，完全可以在他设计的字体中用 &amp;111 来表示微信图标。iconfont 默认以 &amp;xe 表示,因为这一段 unicode 编码不表示任何字符。</p><p>依据上面的原理，要使用 iconfont 的话，就是先引入 「字体」，然后为引入图标的容器设置 font-family，等等....具体按照其网站的操作即可，这就是 unicode 方式生成的原理。</p><p>也可以再 css 的伪类引入，如果 html 编码 &amp;ex111, 在 css 写 \111，这就是 font-class 生成的原理改变大小可以通过调节 font-size。</p><p>svg 的方式才是现在的主流, 使用时要点击一下使用帮助，svg 的方式很好，可以使用其描边、填充，使用的时候可以查一下svg 的用法。</p><h2>纯 css 实现图标</h2><p>搜索 <a href="https://cssicon.space/#/" target="_blank" rel="noopener">css icon</a>，用 css 实现了很多图标，是 css 快速进步的一个好方法。</p><h2>总结</h2><p>好了！其实这一篇笔记很简单，甚至没有做笔记的必要，但是还是当做 web 引入 icon 的方式的记录吧。</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;tips&lt;/h2&gt;
&lt;p&gt;图片不要同时写宽和高，只要写了宽这一个属性，他会按照以前图片的比例自适应宽高的。&lt;/p&gt;
&lt;h2&gt;ps 导出单一图标&lt;/h2&gt;
&lt;p&gt;如果设计师给你一张大的 PSD 格式的图片，可以按照以下步骤导出单个图标:
选中图层 -&amp;gt; depulic
      
    
    </summary>
    
    
      <category term="css" scheme="http://mysterywz.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>一些git知识点</title>
    <link href="http://mysterywz.xyz/passages/%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%87%82%E5%BE%97git%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://mysterywz.xyz/passages/你应该懂得git知识点/</id>
    <published>2018-11-25T10:35:48.000Z</published>
    <updated>2019-10-31T05:41:17.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2018.8.24 晴</p></blockquote><p>在公司用到的VSC是SVN,并且用到的也只是简单的几个命令，昨天我学习了一下Github的一些操作，  觉得很有必要学习一个git了，这对我理解Github的用法也很有帮助，也对我以后有好处。于是我今天从Coursera上注册了一个课程，准备跟随他学习一下Git，笔记将记录在这里.</p><h2>常用命令</h2><p>git rest --hard 是清除工作区和暂存区里面的代码，也就是清除当前未 add，和已经 add 但是没有 commit 的代码git mv readme readme.md git 重命名的简便方式git log -n4 --oneline 最近的 4 次git log --master --graph 图例化git help --web loggit config --local user.name 'wenzhe'gitk -all 图形界面git checkout -b newBranch 创建新分支并切换到git diff 比较两个commit 版本git diff HEAD HEAD^git branch -d branch 删除分支，如果没有合并 git 会提示，此时再 -D 删除最保险git commit --amendgit rebase -i 父亲的commitid，来修改一个commit 或者多个上面那个命令修改多个的时候可能不能直接行，那就 git rebase --continuegit diff --cached 暂存区和 head 指向的 commit 之间的差别git diff 工作区和暂存区的差别，后面可以加文件名详细的比较文件</p><p>git reset HEAD 暂存区的都不要了，还原回工作区变化工作区用 checkout 变暂存区用resetgit checkout -- index.html 把工作区的文件改为和暂存区一样的</p><h2>宏观的理解Git</h2><ul><li>continuous improvement by commits</li><li>simultaneous(同时) stability and development by branches</li><li>improved quality by pull requests</li><li>git都是以git开头，然后后面接空格</li><li><img src="https://i.loli.net/2018/08/24/5b7f664156b51.png" alt="屏幕快照 2018-08-24 上午9.58.01.png"></li></ul><h2>一些不知道但是有用的命令</h2><ul><li>git --version 查看版本</li><li>git help init 查看所有的帮助</li><li>git config --global user.name</li><li>git log --oneline -number 输出log只一行 number为指定数量</li></ul><h2>概念</h2><ul><li>working tree包含了项目的一次commit的文件、目录</li><li>staging area 通过add添加到里面</li><li>local resposition包含了本地的多次commit</li><li>staging area local在.git这个文件夹里</li><li>remote repository在远程</li><li>git status是查看的work tree 和staging area之间状态</li><li>git add add untracked and modify to staging area</li><li>git commit create snapshot of current project</li><li>git clone 得到local repository，可以指定名字在第二个参数</li><li>git remove -v</li><li>git push [-u] [rep] [branch]</li><li>git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push</li></ul><h2>git 的 DAG 模型</h2><ul><li>commit object - a small text file</li><li>Annotaed tag - 特定 commit 的索引</li><li><code>git log --oneline --graph</code> 很好用</li><li>Git IDs 是一个 40 位的 16 进制数，也是 git Object 的名字，Git IDs 通常是四个字母的缩写或者更多的缩写</li><li>git show to show all ids</li><li>git hash-object get file's hash id</li><li>acyclic means no cyclesj</li></ul><h2>git branches</h2><p>master 指向该分支最近的一次提交，head 指向 masterhead 指向当前的分支~ 指向上一次提交~~ 上一次的上一次^1 first parent of the commit^2 second parent of merge commit (比如在 a 节点分出 b 和 c， b&amp;c -&gt; d 在d 运行 ^2 就是c)^^ first parent's first parent</p><p>每个 branch 构成了一个项目，commit 属于一个 branchgit branch 列出所有项目git branch freatureX create branchgit checkout freatureX -&gt; change branchgit branch -b newBranch create and change to newBranchgit 如果指向某个 commit，并想回到它工作，那就要创建一个新的分支继续git branch -d featureX delete branch</p><p>merge:</p><ul><li>git checkout master git merge featureX git branch -d featureX</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;2018.8.24 晴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在公司用到的VSC是SVN,并且用到的也只是简单的几个命令，昨天我学习了一下Github的一些操作，  觉得很有必要学习一个git了，这对我理解Github的用法也很有帮助，也
      
    
    </summary>
    
    
      <category term="git" scheme="http://mysterywz.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何写一个脚本</title>
    <link href="http://mysterywz.xyz/passages/%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
    <id>http://mysterywz.xyz/passages/如何写一个脚本/</id>
    <published>2018-11-20T14:26:42.000Z</published>
    <updated>2019-10-31T05:41:17.384Z</updated>
    
    <content type="html"><![CDATA[<h2>什么是脚本</h2><p>我们在 terminal 运行的 cd，ls，clear 这些都是脚本。</p><p>由于进入目录、列表目录、清空控制台这些需求比较常见，所以系统为我们预设了这些脚本。</p><h2>用途</h2><p>脚本的功能很强大，可以帮我们做一些机械的工作。只是预设的脚本功能比较有限，但不必失望，我们可以通过自己动手写一些自定义脚本来丰富它，并且，它很简单。</p><h2>示例</h2><p>我们通过示例来说明如何写一个脚本。</p><p>接下来实现的功能是这样的：我想只输入 <code>new hello</code> 就能帮我建一个 hello.html，并且每个 html 写入固定的模板。</p><p>我把脚本都放到了本地 「~/scripts」 文件夹里面。</p><ol><li><p>新建文件 「new」，同时新建一个 「index.html」，在 「index.html」 里面写入任意内容</p></li><li><p>打开 「new」，并写入以下内容</p></li></ol><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ -d $1.html ]; then</span><br><span class="line">    echo 'error: file exists'</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line">touch $1.html</span><br><span class="line">cp ~/documents/repos/scripts/index.html $1.html</span><br><span class="line">echo 'successfully created'</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>保存退出，并添加权限 <code>chmod +x new</code></p></li><li><p>在 「~/.bashrc」 文件夹的最后添加这个脚本的路径，比如我的路径是：</p><p><code>export PATH=&quot;/Users/mac/documents/repos/scripts/:$PATH&quot;</code></p></li><li><p>执行 <code>source ~/.bashrc</code></p></li><li><p>执行 <code>new hello</code></p></li><li><p>恭喜你，完成了。</p></li></ol><h2>总结</h2><p>实践往往是理解一个事物最快的方式，希望上面的可以帮助到你。</p><p>如果你还想了解其他的例子，请点击<a href="https://github.com/mysteryven/blog/blob/master/Notes/note-3.md" target="_blank" rel="noopener">click</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;什么是脚本&lt;/h2&gt;
&lt;p&gt;我们在 terminal 运行的 cd，ls，clear 这些都是脚本。&lt;/p&gt;
&lt;p&gt;由于进入目录、列表目录、清空控制台这些需求比较常见，所以系统为我们预设了这些脚本。&lt;/p&gt;
&lt;h2&gt;用途&lt;/h2&gt;
&lt;p&gt;脚本的功能很强大，可以帮我们做一些
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://mysterywz.xyz/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>你所不知道的计算机技巧</title>
    <link href="http://mysterywz.xyz/passages/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E5%B7%A7/"/>
    <id>http://mysterywz.xyz/passages/你所不知道的计算机技巧/</id>
    <published>2018-11-15T14:15:40.000Z</published>
    <updated>2019-10-31T05:41:17.378Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux 篇</h1><h2>linux 程序后台运行与关闭（以 anywhere 为例）</h2><h3>下载</h3><p><code>yarn global add anywhere</code></p><h3>命令</h3><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">anywhere&amp; # 后台运行</span><br><span class="line">jobs      # 查看当时哪些在后台运行</span><br><span class="line">fg        # 切换回后台命令</span><br><span class="line">ctrl + c  # 关闭</span><br><span class="line">ctrl + a  # 回到一个命令的开始</span><br><span class="line">ctrl + e  # 回到末尾</span><br><span class="line">!$        # 代指上一次命令的最后一个字符串</span><br><span class="line">sudo !!   # 忘记加sudo，可以用这个命令重新执行</span><br><span class="line">!xxx      # 重新执行上一次这命令，比如 !vi 执行最近的一次 vi， !cd 执行最近的一次 cd</span><br><span class="line">cd -      # 最近的两次 cd 目录切换</span><br><span class="line">esc + .   # 把上一次最后一个参数打下来</span><br><span class="line">!!:gs/old/new # 替换上一条命令的 old 为 new</span><br><span class="line"><span class="meta">&gt;</span> hi.html # 快速创建文件</span><br><span class="line">man ascii # 快速查看 ascii</span><br></pre></td></tr></table></figure></p><h2>tree 忽略不想被展示的文件夹</h2><p><code>tree -I [dir_name]</code></p><h2>本地文件传到服务器</h2><p><code>rz</code></p><h2>服务器文件下载到本地</h2><p>比如我想下载 user 文件夹到本地</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf  user.tar user/  # compress  </span><br><span class="line">sz # download</span><br></pre></td></tr></table></figure></p><p>完成之后就可以去你的电脑里面寻找一下了，它的文件名是 「user.tar」</p><h2>svn display special user's commits</h2><p><code>svn log | sed -n '/USERNAME/,/-----$/ p'</code></p><h2>svn back to special revision</h2><p><code>svn merge -rHEAD:9</code></p><h1>Vim 篇</h1><p><code>&gt;G</code> 增加此行到文档末尾的缩进层级</p><h1>VPN 篇</h1><h2>shadowsocks (目前在用）</h2><p>https://shadowsocks.nu/</p><h2>蓝灯 （很垃圾，估计以后不会用了）</h2><p>https://github.com/getlantern/lantern</p><h2>云梯</h2><p>https://www.yuntipub.com/</p><h2>影梭</h2><p>https://i.ssvpn.me/blog/id=6</p><h2>枫叶主机</h2><p>https://www.fyzhuji.com/shadow.html</p><h2>佛跳墙</h2><p>https://i.ssvpn.me/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Linux 篇&lt;/h1&gt;
&lt;h2&gt;linux 程序后台运行与关闭（以 anywhere 为例）&lt;/h2&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;yarn global add anywhere&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;命令&lt;/h3&gt;
&lt;p&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="技巧" scheme="http://mysterywz.xyz/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>使用vue-cli来构建单页面应用或多页面应用</title>
    <link href="http://mysterywz.xyz/passages/%E4%BD%BF%E7%94%A8vue-cli%E6%9D%A5%E6%9E%84%E5%BB%BA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E6%88%96%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>http://mysterywz.xyz/passages/使用vue-cli来构建单页面应用或多页面应用/</id>
    <published>2018-11-14T13:36:17.000Z</published>
    <updated>2019-10-31T05:41:17.380Z</updated>
    
    <content type="html"><![CDATA[<h1>单页面应用配置</h1><h2>安装 vue-cli</h2><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn global add @vue/cli</span><br><span class="line"></span><br><span class="line">yarn global add @vue/cli-service-global</span><br></pre></td></tr></table></figure></p><h2>初始化项目</h2><p><code>vue create hello-world</code></p><h2>运行项目</h2><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn serve</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure></p><h2>配置</h2><p>如果我如下配置，当我运行 <code>yarn build</code> ，我将在项目的根目录下得到一个 dist1 文件夹，并且，我能在此目录下打开 test.html 而不会发现找不到 css、js 链接的情况。</p><p>原因在于我使用了 ./ 的 baseUrl。当然，我也可以使用 /dist1/。</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vue.config.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  baseUrl: <span class="string">'./'</span>,</span><br><span class="line">  outputDir: <span class="string">'dist1'</span>,</span><br><span class="line">  indexPath: <span class="string">'test.html'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1>多页面应用配置</h1><p>接着上面单页面的配置，我们来进行多页面应用的配置。</p><p>在 vue-cli 2 的时候，配置好像还蛮麻烦的，只是我没有配置过。我在配置 vue-cli 3 的时候感觉很简单，我们几乎不需要什么操作，基本目录结构和配置文件如下所示：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hello-vue</span><br><span class="line">  src</span><br><span class="line">    assets</span><br><span class="line">    components</span><br><span class="line">    footer</span><br><span class="line">      footer.html</span><br><span class="line">      footer.js</span><br><span class="line">    index</span><br><span class="line">      index.html</span><br><span class="line">      index.js</span><br><span class="line">  ...</span><br><span class="line">  dist</span><br></pre></td></tr></table></figure></p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># vue.config.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baseUrl = <span class="string">'/dist/'</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  baseUrl: baseUrl,</span><br><span class="line">  runtimeCompiler: <span class="literal">true</span>,</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">    entry: <span class="string">'src/index/index.js'</span>,</span><br><span class="line">    template: <span class="string">'src/index/index.html'</span>,</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    title: <span class="string">'Index page'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    footer: &#123;</span><br><span class="line">      entry: <span class="string">'src/footer/footer.js'</span>,</span><br><span class="line">      template: <span class="string">'src/footer.html'</span>,</span><br><span class="line">      filename: <span class="string">'footer.html'</span>,</span><br><span class="line">      title: <span class="string">'footer page'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      proxy: <span class="string">'http://localhost:8080/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的一点就是「devServe」。</p><p>我的 baseUrl 是 dist 目录，并且 *.html 也是 dist 的直接子目录， 所以可以直接这样写。这样写了之后我就能在这些页面之间跳转了。</p><p>在网上，我还看到了另外一个人的 devServer 的做法，原理是一样的，都是因为如果不设置 devServer 的话，浏览器就没有返回的东西。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  historyApiFallback: &#123;</span><br><span class="line">  rewrites: [</span><br><span class="line">  &#123; from: /\/index/, to: &apos;/index.html&apos; &#125;,</span><br><span class="line">  &#123; from: /\/footer/, to: &apos;/footer.html&apos; &#125;</span><br><span class="line">  ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>alias</h2><p>这一项可以使我们引入文件变得很方便，值得记录，放在最后</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vue.config.js</span><br><span class="line">configureWebpack: &#123;</span><br><span class="line">   resolve: &#123;</span><br><span class="line">     alias: &#123;</span><br><span class="line">       &apos;assets&apos;: &apos;@/assets&apos;,</span><br><span class="line">       &apos;components&apos;: &apos;@/components&apos;,</span><br><span class="line">       &apos;css&apos;: &apos;@/modules/css&apos;,</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>使用的话，比如 src/main.js 想引用 modules/css/common.css，则只需</p><p><code>import css/common.css</code></p><p>写到这里，关于 vue-cli 的使用已经基本介绍完毕了，后续可能会补充一些小的细节吧！</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;单页面应用配置&lt;/h1&gt;
&lt;h2&gt;安装 vue-cli&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
    
      <category term="vue" scheme="http://mysterywz.xyz/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>css笔记之宽度与高度</title>
    <link href="http://mysterywz.xyz/passages/%E5%AE%BD%E5%BA%A6%E5%92%8C%E9%AB%98%E5%BA%A6/"/>
    <id>http://mysterywz.xyz/passages/宽度和高度/</id>
    <published>2018-11-10T08:37:58.000Z</published>
    <updated>2019-10-31T05:41:17.391Z</updated>
    
    <content type="html"><![CDATA[<h2>总结</h2><p>如何在写 css 的时候不要固定死 width、height。</p><p>字体的默认行高是有字体设计师写的，所以才会出现不同字体 div 不一样高的情形。</p><p>「font-size」 不影响 div 的高度，「line-height」 影响。</p><p>1em 等于两个英文字符，一个汉字。</p><p>如果一个单词很长，超越了容器的宽度，默认是不会换行的，除非加连字符或者 「word-break」， div 的宽度不是有字体长度决定的，span 的宽度是由字体长度决定的 span（内联元素）的上下 padding margin 都不影响div的高度。</p><p>文档流中，内联元素从左到右，超出之后另起一行，块级元素每次都另起一行。</p><p>div 的高度是由它内部文档流中元素的总和决定的。</p><p>脱离文档流之后，div 的高度将不计入它。</p><p>使用上下 padding 相等来使 div 垂直居中</p><h2>汉字对齐</h2><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>联系方式<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:justify;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>超出隐藏</h2><p>搜索关键词 <code>css multi line text ellipsis</code></p><h2>文字垂直居中</h2><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2>margin 合并</h2><p>如果父元素没有 border、 padding 来挡住子元素的 margin ，会使父子上下 margin 合并。</p><h2>实现 1:1 的 div</h2><p><code>padding-top: 100%</code></p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;如何在写 css 的时候不要固定死 width、height。&lt;/p&gt;
&lt;p&gt;字体的默认行高是有字体设计师写的，所以才会出现不同字体 div 不一样高的情形。&lt;/p&gt;
&lt;p&gt;「font-size」 不影响 div 的高度，「line-height」 
      
    
    </summary>
    
    
      <category term="css" scheme="http://mysterywz.xyz/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>人工智能未必可怕</title>
    <link href="http://mysterywz.xyz/passages/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%AA%E5%BF%85%E5%8F%AF%E6%80%95/"/>
    <id>http://mysterywz.xyz/passages/人工智能未必可怕/</id>
    <published>2018-09-26T13:40:23.000Z</published>
    <updated>2019-10-31T05:41:17.374Z</updated>
    
    <content type="html"><![CDATA[<p>之前有一段时间我相信这样一个观点：有朝一日，计算机会控制人类。今天我看了吴军的几篇文章，我明白过来了，原来这是不可能的。</p><p>这个事情也让我知道了认知低有多恐怖，认知低的人永远看不到外面的世界，这是我一直很怕的事情，我一直非常想的一件事情就是：我要活明白，不要浑浑噩噩的。</p><p>首先我想简单说明一下吴军的观点，他认为，由于电子计算机的极限所在，所以人工智能永远无法企及人类思维的高度，电子的运动等价于机械运动，而人的意识是不定的。 类比通俗一点的知识的话，就相当于永动机是不可能的一样，机器的制造也总有一个极限，这是建立在缜密的数学推理上的，人类永远无法超越这个极限的。 更多的，他认为，世界上的问题太多了，而人工智能能解决的问题却非常少，所以我们还不应该担忧人工智能未来的危害，而应该想如何使用它。</p><p>我很支持他的观点，毕竟一方面来讲，还没了解就怕纯粹是懦夫的行为！另一方的这个潮流也不是我一己之力可以改变的，我做的只是如何在其中活的很好，之后再去思考如果改变的问题，毕竟我的境界还没达到，怎能断定这个方向是对人类好还是坏呢？</p><p>我今天还知道了一个很棒的观点，吴军提倡一种思维，先宏观的考虑事物的极限，再来考虑如何实现，具体方法是什么。这是图灵的思考模式，非常值得我借鉴。如果我用这个观点，应该可以让我辨明很多空虚、不切实际的猜想，毕竟人的感觉很有限呢，在事情上，我们应该相信缜密的推理。</p><p>呼呼呼，今天早上晚起了几分钟就没赶上车，折腾了半天坐的地铁还是迟到了，晚上回来去做了一个发型。回来路上在我后面的那个女生超级漂亮，我提前下车，偷偷的看她，哇，她的手好漂亮好漂亮，并且头发超级干净，想让她做我女朋友怎么办？ :)</p><p>（完）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有一段时间我相信这样一个观点：有朝一日，计算机会控制人类。今天我看了吴军的几篇文章，我明白过来了，原来这是不可能的。&lt;/p&gt;
&lt;p&gt;这个事情也让我知道了认知低有多恐怖，认知低的人永远看不到外面的世界，这是我一直很怕的事情，我一直非常想的一件事情就是：我要活明白，不要浑浑
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么是路由</title>
    <link href="http://mysterywz.xyz/passages/%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1/"/>
    <id>http://mysterywz.xyz/passages/什么是路由/</id>
    <published>2018-09-24T13:40:23.000Z</published>
    <updated>2019-10-31T05:41:17.375Z</updated>
    
    <content type="html"><![CDATA[<h2>什么是路由</h2><p>根据路径展示给用户不同的页面就是路由，表现在后端方面的话，就是比如我们请求<code>www.mysteryven.com/page1</code>， 后端返回给我们<code>page1</code>所对应的页面，当我们请求<code>www.mysteryven.com/page2</code>，后端返回给我们<code>page2</code>对应的页面，在前端方面展示的话，可能就类似于切换tab的形式。通过用户的操作来展示给用户不同的『界面』,更通俗的讲，就是我们根据用户的点击来切换UI！我也没就这么简单。</p><h2>路由的作用</h2><p>通过对路由的巧妙使用，我们能实现无刷新『切换页面』，非常方便我们构建单页面应用！好吧，其实是假的切换页面，另外呢还有一个功能，就是可以保存页面当前的状态然后分享出去，对方打开依然还保持着页面的状态。</p><h2>原理</h2><p>我们先来模拟一下<code>vue-router</code>的原理。</p><p>代码请看下面链接</p><p>--&gt; <a href="https://mysterywz.xyz/Assignments/jquery-router/" target="_blank" rel="noopener">link</a></p><p>这里说明一下，这样的展示效果是没有实现刷新依然保存的那种效果，因为那个需要后端的配合，如果想和后端配合，也很简单，只需要在请求这几个路径时，让后端返回给你相同的页面就行了，具体页面的展示逻辑，需要我们前端来做。</p><p>比如说我们可以写Node.js的一小段路由的代码：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (path === <span class="string">'/'</span> || <span class="string">'/tab1'</span> || <span class="string">'tab1'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> string = fs.readFileSync(./index.html)  </span><br><span class="line">    response.statusCode = <span class="number">200</span> </span><br><span class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>)</span><br><span class="line">    response.write(string)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果只由前端来实现路由的效果的话，我们可以使用锚点的方法来代替。代码请点击下方链接</p><p>--&gt; <a href="https://mysterywz.xyz/Assignments/anchor-router/" target="_blank" rel="noopener">link</a></p><p>这个我认为也是vue的原理，我故意的把锚点的链接都弄的和vue的一致。</p><hr><p>今天有点晚了，明天我看了<code>vue-router</code>再来写后半部分</p><p>现在已经是第二天了，我今天去看牙医，回来弹了一个小时琴就快11点了，现在来写这篇博客。</p><p>我发现用了vue之后上面的问题直接解决了，还要什么后端配合嘛？并且超级简单的代码，原来这就是传说中的单页面应用，以前我觉得神乎其神，现在就是也就这样嘛。我的vue版本代码也做完了，但是基本是copy的官方版本，毕竟是个简单的demo嘛，下一步把vue在看一遍，接着写完那个vue的第一个毕设。</p><p>--&gt;<a href="https://mysterywz.xyz/Assignments/vue-router/" target="_blank" rel="noopener">link</a></p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;什么是路由&lt;/h2&gt;
&lt;p&gt;根据路径展示给用户不同的页面就是路由，表现在后端方面的话，就是比如我们请求&lt;code&gt;www.mysteryven.com/page1&lt;/code&gt;， 后端返回给我们&lt;code&gt;page1&lt;/code&gt;所对应的页面，当我们请求&lt;code&gt;www
      
    
    </summary>
    
    
      <category term="js" scheme="http://mysterywz.xyz/tags/js/"/>
    
  </entry>
  
</feed>
