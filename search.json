[{"title":"简谈web性能优化","url":"/passages/简谈web性能优化/","content":"\n前几天去面试，面试官全程围绕 web 性能优化的主题展开，问的我是一头雾水。由于没回答上几道题，结果自然也可想而知。\n\n我回来之后赶紧查一下资料，发现这里面的坑，还真的蛮大的，下面我就来介绍一下。\n\n当我们访问一个网址的时候，大概有以下几个过程：\n\n1. 查看是否有缓存\n2. 通过 DNS 来查到域名对应的 IP 地址\n3. 建立 TCP 连接\n4. 发送 HTTP 请求\n5. 请求到 HTML 后再根据页面里具体的请求来请求 CSS、IMG、JS 文件\n\n如果想要优化，也肯定是在这几个步骤上面想办法。\n\n如果我们想优化第 2 步，可以通过减少不同的域名请求来达到减少 DNS 查询的目的。\n\n优化 TCP 连接可以开启连接复用（添加请求头 `keep-alive`)。\n\n优化 HTTP 请求方面，我们不要滥用 cookie，已减小请求体积；也可以使用 `cache-control` 、`Expires` 等缓存机制，也可以同时发送多个请求（注意，一个域名有请求发送限制，此时可以通过增加域名的方式来解决）\n响应 HTTP 请求可以通过 `ETag` 的方式响应 304，这样就减少响应第四部分的体积了，当然了，也可以对请求的第四部分使用 gzip 的方式压缩。\n\n但是我们增加域名了之后也会增加 DNS 请求的负担，这就矛盾了，对此情况我们要具体情况具体分析了。一般来说，如果用户带宽足够，文件很多就增加域名，文件很少就尽量减少域名了。\n\n对于请求 HTML ，我们最好在文件开头就指定 `DOCTYPE` , 这样就不用浏览器去判断文档类型了。\n\n请求 css 、js 、 img 之类的文件呢？一个优化策略就是使用 CDN（内容分发网络），它能加速请求的响应，也能增加同时下载数（下载可以同步，解析不同步）。\n\nps: CDN 是把内容分发到各地，使各地的人访问都能较快\n\n另外一个策略就是我们组织文件的方式来，这个我在面试中被问到了。由于解析 css 会重新渲染 DOM 树（在 chrome 中 css 放在后面会阻塞渲染），所以我们必须把 css 放在 `head` 里面，让 css 尽早下载，既不让用户看到残缺页面，也能优化我们的页面。\n\n由于 js 只能一个个的解析，并在解析的同时会阻塞解析 HTML 下面的页面，所以我们要把 js 放在后面，这样能让 js 取到所有的 dom 节点，也能让用户看到完整的网页。\n\n对于优化 img 的话，我们可以使用懒加载的方式，也就是等用户快要看到的时候加载。\n\n好了，优化策略写到这就写完了，希望对你有帮助。\n\n（完）\n"},{"title":"继承的两种写法","url":"/passages/js继承的写法/","content":"\n前几天去面试的时候被问到了这个问题，今天来重新整理一下，并比较一下二者的区别。\n\n如果使用 ES5 ，写起来还挺麻烦的。\n\n```\nfunction Animal(name) {\n  this.name = name\n}\n\nAnimal.prototype.run = function() {\n  console.log('Hi, I am ' + this.name)\n}\n\nfunction Dog() {\n  Animal.apply(this, arguments)\n  this.age = 12\n}\n\nvar f = function(){}\nf.prototype = Animal.prototype\nDog.prototype = new f()\n\nlet dog = new Dog('xxx')\ndog.run()\n```\n\n如果使用 ES6 的 Class 语法，就简单多了。\n\n```\nclass Animal {\n  constructor(name) {\n    this.name = name\n  }\n  run() {\n    console.log('Hi, I am ' + this.name) \n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name)\n    this.age = 12\n  }\n}\n\nlet dog = new Dog('xxx')\ndog.run()\n```\n\n上面实现的效果完全相同。   \n\n其实 class 只是一个语法糖而已，它能实现前一种写法一样的功能。可能你会想，既然 class 的写法简单并也没什么不能做的，那我只学 class 就好了，还学原型的写法干什么？其实两种写法都有优劣。首先，只学 class 并不能了解继承的本质，另外，在某些情况下，class 并不简便。\n\n比如，我们想给 Animal 的原型上面添加一个字段而不是方法，用 ES5 我们只需要写 `Animal.prototype.xxx = 'yyy'` 即可，但是在 class 那种写法就要麻烦一点了。\n\n```\nget xxx() {\n  return 'yyy'\n}\n```\n\n很多相对立的东西都可以采用「二元论」的策略去认识。大的如同 Vue 和 React，小的如同 JS 继承的两种写法，它可以让我们快速抓住事物的本质并快速的学会。我想很多人都会这么学吧。\n\n（完）","tags":["js"]},{"title":"手写bind","url":"/passages/手写bind/","content":"\nbind 是在 ES5 新加入的语法，具体的语法 MDN 都有。但有一点需要额外注意一下：bind 会返回一个新的函数。也就是说：它会修改 this 的指向，并返回新的函数体。\n\n接下来，我来讲一下手写 bind 的思路。\n\n首先我们要明白 bind 的用途：它是为了改变默认 this 的，如：\n\n```js\nvar obj = { a: 1 }\nfunction yyy(a) {this.a = a}\nvar xxx = yyy.bind(obj)\nxxx(a) = 3\nconsole.log(obj.a) // 3\n```\n\n此时 xxx 的代码实际上是下面这样的\n\n```js\nfunction xxx(newA) {\n   obj.a = newA \n}\n```\n了解了如何使用，我们才能往下写，我们来为函数的原型添加一个 `myBind` 方法\n\n```js\n(Function.prototype.myBind = function(otherThis) {\n  // 当前的 this 是 yyy，如果 this 的类型不是函数，就返回\n  if (typeof this !== 'function') {\n    return\n  }\n  // 获取 yyy 除去第一项后的参数，也就是除去 this 的剩余参数\n  var bindArgs = Array.prototype.slice.call(arguments, 1) \n  var bindArgsLength = bindArgs.length  // 这句话很重要，代码后有解释\n\n  var fBind = this // yyy ，也是要绑定到哪里\n  var fNP = function(){}  // 中间量，以便生成的 xxx 和原来函数毫无瓜葛\n  var fBound = function() {\n    bindArgs.length = bindArgsLength // 必须重置 bindArgs 的长度\n    bindArgs.push.apply(bindArgs, arguments) // 组合两次的数据\n\n    return fBind.apply(otherThis, bindArgs) // 用 apply 方法为新的返回值绑定用户指定的 this\n  }\n\n  if (this.prototype) { // Function.prototype 没有 prototype\n    fNP.prototype = this.prototype\n  }\n\n  fBound.prototype = new fNP() \n  \n  return fBound\n})()\n\n```\n\n需要说明一下重置 bindArgs 那一句话：\n\n因为 bindArgs 是和 fBound 同一级别的，当执行 `myBind` 这个函数之后，fBound 和 bindArgs 都只有一份，但是可能多次调用 myBind 返回的函数（这里是 xxx）并传参，如果不重置，我们两次调用 xxx('aaa')，那 bindArgs 的长度就变为 2 了，但我们希望两次调用不能被影响，只能受父亲 yyy 传参的影响。由于每次添加都是 push 到后面，所有每次只要恢复成以前的长度即可。\n\n好了，我们已经大致完成了，但是还要一个缺陷：不支持 new，真正的 bind 方法在使用 new 之后的 this 还是指向 new 新生成的对象。\n\n举例来说，我们希望得到下面的效果：\n\n```js\nvar obj = { a: 1 }\nfunction yyy(a) {this.a = a}\nvar xxx = yyy.bind(obj)\nvar xxxxxx = new xxx('你好')\nconsole.log(obj.a) // 1 \nconsole.log(xxxxxx.a) // 你好\n```\n\n而我们现在的代码是如何的呢？ 由于我们没做判断，我们返回的函数实际是：\n\n```js\nfunction xxx(newA) {\n   obj.a = newA \n}\n```\n\n结果是：xxxxxx.a 未定义，而 obj.a 是你好\n\n如何解决？只需在执行 apply 的时候绑定更换绑定的 this 就好了\n解决的关键是 this 到底指向什么，如果使用 new 操作符，那个时候的 this 就是指向新的对象。\n\n```js\n(Function.prototype.myBind = function(otherThis) {\n  // 当前的 this 是 yyy，如何 this 的类型不是函数，就返回\n  if (typeof this !== 'function') {\n    return\n  }\n\n  var bindArgs = Array.prototype.slice.call(arguments, 1) // 获取 yyy 除去第一项后的参数\n  var bindArgsLength = bindArgs.length \n\n  var fBind = this // yyy ，也是是要绑定到哪里\n  var fNP = function(){}  // 中间量，以便生成的 xxx 和原来函数毫无瓜葛\n\n  if (this.prototype) { // Function.prototype 没有 prototype\n    fNP.prototype = this.prototype\n  } // 放在前面便于理解\n\n  var fBound = function() {\n    bindArgs.length = bindArgsLength // 必须重置 bindArgs 的长度\n    bindArgs.push.apply(bindArgs, arguments) // 组合两次的数据\n      \n      // 如果使用 new 操作符，此时 this 指向的是新生成的对象，那么 fNP.prototype.isPrototypeOf(this) === true\n      // xxxxxx -> xxx -> FNP\n      return fBind.apply( fNP.prototype.isPrototypeOf(this) ? this: otherThis, bindArgs) \n  }\n\n  fBound.prototype = new fNP() \n  \n  return fBound\n})()\n```\n\n写完了，昨天花了一个下午的时间在理解这个问题，我认为理解起来还是有点难度的，希望帮助到你。\n\n（完）\n\n\n\n","tags":["js"]},{"title":"js里面new到底有什么用？","url":"/passages/js里面new到底有什么用？/","content":"\n最近要准备面试了，于是拿起以前的知识点复习一下，今天看到了一片博文讲 `new` 讲的非常不错，于是我再简略的概括一下亦当复习了。\n\n首先要明白，`new`其实是一个语法糖。\n\n如果我们创建了一个构造函数叫 `Food`，当我们执行 `new Food` 的时候会发生什么呢？\n\n1. js 帮我们在 `Food` 内部声明一个临时的空对象\n2. 把 `Food` 里面 this 指向的属性或者方法都放到临时对象里面\n3. 让临时对象的一个叫做 `_proto` 的属性指向 `Food` 的 `prototype`\n4. 返回这个临时对象\n\n当然了，我们也可以不用 `new` 操作符，如果不怕麻烦的话。\n\n另外的，一个新的对象都有一个 `constructor` 属性，作用是为了指名构造它的是哪一个对象。它不会自动修改。\n\n在构造对象的时候如果我们使用下面的方式修改原型    \n\n```\n    Food.prototype = {\n        ...    \n    }\n```\n\n这样之后，`prototype` 的指向就完全变了，那 `constructor` 也就变了，此时我们还需要手动改回来，在 `Food.prototype` 添加 `constructor` 属性，或者不让 `Food.prototype` 是一个新对象，直接如下方式修改：\n\n```\nFood.prototype.toString = ...\n``` \n\n（完）\n","tags":["js"]},{"title":"单元测试的必要性","url":"/passages/单元测试的必要性/","content":"\n我本来没有听过「单元测试」，更别提意识到单元测试的重要性了。最近在写组件库的时候，了解到了这方面的知识，并写了几个单元测试，发现它确实是必不可少的一环，它不仅让你对自己的代码更自信，还能让别人更信任你的代码，你以为只有这些吗？当然不是，它还能让你的代码更健康的迭代。总之，单元测试是所有软件工程师必须要做的。\n\n你可能会疑问，有了测试人员，我写单元测试还有必要吗？当然有必要，因为单元测试只是测试中的一小部分。\n\n测试按照种类可以大致分为两类，黑盒测试和白盒测试。按照规模由大到小可以分为：单元测试，模块测试，功能测试，集成测试\n\n什么是黑盒测试？有一个例子就是测试人员测试，他们不懂我们的代码，通常会进行一些边界情况的测试。而我们的单元测试就是白盒测试，单元测试是很有必要的，虽然我们写代码的时候很成功，但是不能保证以后的代码对现在的代码有没有影响，我总不能写完一个组件，把之前的全部组件再手动测一次吧？\n\n目前，很多人没意识到单元测试的重要性，其实也不是咱们懒，是有很多客观原因摆着的。由于现在前端还处于发展的阶段，框架的还没有稳固呢，这不，vue 3 要发布了，所以很多人都在忙着学习框架的知识，测试先放一会吧。并且我们现在的开发现状也不允许我们写测试，哪有时间呀？今天提的需求，明天可能就要上线了，能用就不错了！\n\n结合其他语言的发展历程，这一块肯定是要被重视起来的。写代码还需要测试虽然麻烦，但是好处大大的有。\n\n当然了，如果你实在不喜欢单元测试，也不必慌，不是所有的代码都需要单元测试。\n\n比如一般的不可复用的业务代码，根本不需要单元测试，如果你公司里的登录、注册、订单类的流程基本一致，那就可以把公用的代码抽离出来，做成组件，并给它们添加单元测试，这是必要的。\n\n还有就是自己造的组件库，比如我目前就是在写一个组件库。很坑，其实我写这篇文章不仅仅是为了总结这一块的知识，我也在说服我自己写测试...好吧，写到这里，我相信我自己也信服了，乖乖写测试去咯，争取覆盖率 95% 以上 ！\n\n\n(完)\n"},{"title":"自建一个文件上传的小demo（前后台）","url":"/passages/实现一个简单的图片上传功能（前后台）/","content":"\n\n最近计划做一个图片上传的组件，在前期准备工作中就遇到了一些困难，比如：如何用 ajax 发送 form 表单的数据，如何把发送过去的数据存到服务器，现在，我已经解决了这些问题，基本实现了图片上传的原理，下面就是对应的代码。\n\n如何去使用呢？\n1. 先把第一部分的 html 代码拷贝到本地，用 server 打开，或者直接拷贝到 JSbin 此类的在线编辑器也行。\n2. 拷贝第二部分的 Node.js 的代码，安装所需要的依赖（express, multer），之后运行它。\n3. 在你的 html 代码部分点击上传吧，看看控制的的 network 有什么反应，然后再去你的 Node.js 端看一下是否多了一个 uploads 目录呢？如果是，恭喜你，成功了！\n4. 如果有任何问题，欢迎联系我，联系方式看 「关于」。\n\n```html\n<form>\n    <input type=\"file\" name=\"img\" id=\"input\">\n</form>\n<script>\n    let formData = new FormData()\n    input.addEventListener('change', ()=>{\n       formData.append('img', input.files[0])\n       let xhr = new XMLHttpRequest()\n    \n    xhr.open('POST', 'http:127.0.0.1:3000/upload')\n    xhr.onload = () => {\n      console.log('success')\n    }\n    \n    xhr.onerror = () => {\n      console.log('error')\n    }\n    \n    xhr.send(formData)\n      \n    })\n</script>\n    \n```\n\n\n```node.js\n\nconst express = require('express') \nconst multer  = require('multer')\nconst upload = multer({ dest: 'uploads/' })\n\nconst app = express()\n\n// img 的名称需要和 formData 的数据的 key 相匹配\napp.post('/upload', upload.single('img'), function(req, res) {\n   res.header(\"Access-Control-Allow-Origin\", \"*\"); // 设置跨域\n   res.send('我收到了你的文件，并存到了 uploads目录')\n})\n\napp.listen(3000, function () {\n  console.log('开始监听了')\n})\n\n```\n\n由于是个简单的 demo，就没有继续添加图片预览的功能了，后续我会在我的组件库中加入这个，如果你感兴趣，欢迎联系我。\n\n（完）\n\n\n\n\n\n\n\n\n","tags":["js"]},{"title":"小程序的几个坑","url":"/passages/小程序的几个坑/","content":"\n1. 小程序的底部栏或者顶部栏要用 cover-view 标签，以防页面中有 map 等元素浮到它的上面\n\n2. 双层循环如此写：\n```html\n<view wx:for=\"{{lists}}>\n    <view wx:for=\"{{lists.goods}}\" wx:for-item=\"good-item\" wx:for-index=\"good-index\">\n          {{good-item}}\n     </view>\n</view>\n```\n\n3. 跳转 tab 页面只能 switchTab，这个好好注意一下\n\n4. canvas 显示网络中的图片\n\n```js\ngetImg(id).then(res => {\n    let imgPath = res.xxx // 你的图片路径\n\n    wx.getImageInfo({\n          src: imgPath,\n            success: (res) => {\n              const content = wx.createCanvasContext('myCanvas')\n              content.drawImage(imgPath, 0, 0, 150, 100)\n              content.draw()\n          }\n     })\n})\n```\n\ngetImg 是代表异步获取图片链接的代码，小程序比较蛋疼的就是无法把网络地址的图片直接展示在画布上，所以需要我们先获取到图片，再用小程序的方法获取图片的临时链接，最后把临时链接画到画布上。\n\n5. canvas 使用 rpx\n\n```js\nwx.getSystemInfo({\n  success: (res) => {\n    this.setData({\n        rpx: res.windowWidth / 375\n    })\n  }\n})\n```\n\n小程序的画布是不支持 rpx 的，这一点也很烦，所以需要我们手动写好 rpx 的函数，然后在需要使用单位的地方使用 rpx 得到返回值来使用。\n\n（完)\n"},{"title":"轮播组件和vue结合的一次bug","url":"/passages/ vue的mounted引发的bug/","content":"\n这几天我在做vue项目的时候遇到了一个坑，导致我上个周六就没好好做项目，一直到今天才得以解决。\n\n是这样的，我在渲染轮播图的时候，一直出现加载到了数据但是无法滑动的情况，当我换成静态的数据就有办法滑动了，这让我很费解。后来我询问了一个朋友，他帮我解决了，原因如下：\n\n我在还没获取完数据就把轮播初始化了。\n\n额，对就是这么简单，我把轮播放到 mounted 里面了，尽管我是在 created 的生命周期里请求的数据，但是当所有的dom节点都加载完成了，数据还没请求完毕，而这时候轮播已经初始化了。知道这个原因之后，我把初始化轮播的操作放到请求完数据的 nexttick ，然后就成功了！\n\n我去，这是我学习 vue 第一个大坑啊！解决完真开心。\n\n以前都没用过 nexttick ，这次也算是用的恰到好处。\n\n以上\n（完）\n\n\n","tags":["vue"]},{"title":"表单美化小技巧","url":"/passages/css笔记之表单美化技巧/","content":"\n## 去掉本身的 outline\n\n```\ninput[type=text]:focus {\n  outline: none;\n  border-color: blue;\n}\n```\n\n不要定 input 的宽高，用 padding 的形式做出来\n可以通过调节 font-size 来调节光标的大小\n高度和行高一样就是居中的\ninput 会有自动补全功能, autocomplete=\"off\" 可以关掉他\n\n上传文件后立马上传，要监听 input 的 onchange\n```js\n// search jquery get formData\nlet formData = new FormData()\nformData.append('file', input.files[0])\n\najax.....\n```\n\nbutton 会自动上下居中，如果不是的话且文字只有一行可以用 line-height == height 来使它居中\n做动画用 visibility 属性`\n\n\n","tags":["css"]},{"title":"BFC的作用","url":"/passages/css笔记之BFC/","content":"\nBlock formatting content\n\n如何创建 BFC ?\n\n父元素 float、absolute、inline-block、overflow 不为 visible\ndiplay: table-cell、flow-root 等\ndisplay: flow-root 只有一个触发 BFC 的功能\n\n它可以把内部的元素都包起来，也可以和同级的其他元素划清界限\n最好不要用 BFC 来清除浮动，会有副作用\n\nBFC 实在不常用，我只用到过一次，比较实用的一个功能就是可以去掉父子元素的 margin 合并，\n但是由于除了 flow-root ，其他属性都有未知的副作用，而flow-root浏览器的支持不太好。所以还是不要用的好，解决 margin 合并的话\n可以用 padding、border 来挡住。\n\n总结一下，BFC 完全可以不使用！\n\n(完)\n\n\n\n\n\n\n","tags":["css"]},{"title":"移动端页面布局的几点注意事项","url":"/passages/css笔记之移动端页面布局/","content":"\n\n## 媒体查询 \n语法如下:\n```css\n@media (min-width: 400px) and (max-width: 800px) {\n  body {\n    background: red;\n  }\n}\n\n<link rel=\"stylesheet\" href=\"./style.css\" media=\"(min-width: 600px) and (max-width: 900px)\">\n```\n\n有个新闻网站很好的实现了响应式布局: [smashingmagazine](https://www.smashingmagazine.com/articles/)\n响应式的本质其实就是做多版，通过媒体查询来选择哪一个\n\n## meta 中 viewport 属性\n\n`html\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n`\n\n如果 html 文件里面不加上面那句话，那在手机端的页面宽度就会伪造成 980px，然后根据手机的宽度等比例的把页面宽度缩小。比如 iphone6 的宽度为 375px，那访问同一个页面一个元素的大小变为原来的 375/980。\n\n## 移动端与 pc 的不同\n\n没有 hover\n没有 resize \n没有滚动条\n有  touch\n没有 IE 浏览器！！！\n\n## flex 布局\n\n有一篇非常好的博客 [flex布局](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)\n\n##  手机端布局的注意事项\n\n一个小的知识点，给一个没有宽度的块级元素加负 margin，会让他的宽高撑出去。\npc 有滚动条的原因是有宽度，为了避免，要用 width auto\ncalc属性可以多用一下，比如 `width: (25% -8px)`, 接着设置他们的 margin 为 8，这样不管怎么变，两个元素都是 8px\n的间距\n\n\n(完)\n\n\n\n\n\n\n\n\n\n","tags":["css"]},{"title":"页面引入图片的几种方式","url":"/passages/css笔记之icon/","content":"\n## tips \n\n图片不要同时写宽和高，只要写了宽这一个属性，他会按照以前图片的比例自适应宽高的。\n\n## ps 导出单一图标\n\n如果设计师给你一张大的 PSD 格式的图片，可以按照以下步骤导出单个图标:\n选中图层 -> depulicate layer(选择 new) -> (image-trim)\n后续可以在 PS 调整 image 的 size\n\n\n> 下面讲述页面引入 icon 的几种方法。\n\n## img \n\n优点是可以自适应宽高比例，写起来也很简单。\n\n## background \n\n设置 inline-block, width, height 即可\n\n## css sprites \n\n网上搜索 「css sprites generator」即可，但是我以前都没听过。\n\n## iconfont\n\n它的原理是把字体设计成图标，比如一个字体的编码 &111，它来表示 A，现在字体设计师为了表示一个微信图标，完全可以\n在他设计的字体中用 &111 来表示微信图标。\niconfont 默认以 &xe 表示,因为这一段 unicode 编码不表示任何字符。\n\n依据上面的原理，要使用 iconfont 的话，就是先引入 「字体」，然后为引入图标的容器设置 font-family，等等....\n具体按照其网站的操作即可，这就是 unicode 方式生成的原理。\n\n也可以再 css 的伪类引入，如果 html 编码 &ex111, 在 css 写 \\111，这就是 font-class 生成的原理 \n改变大小可以通过调节 font-size。\n\nsvg 的方式才是现在的主流, 使用时要点击一下使用帮助，svg 的方式很好，可以使用其描边、填充，使用的时候可以查一下\nsvg 的用法。\n\n## 纯 css 实现图标\n\n搜索 [css icon](https://cssicon.space/#/)，用 css 实现了很多图标，是 css 快速进步的一个好方法。\n\n## 总结\n\n好了！其实这一篇笔记很简单，甚至没有做笔记的必要，但是还是当做 web 引入 icon 的方式的记录吧。\n\n(完)\n\n\n\n\n\n\n","tags":["css"]},{"title":"一些git知识点","url":"/passages/你应该懂得git知识点/","content":"\n> 2018.8.24 晴\n\n\b在公司用到的VSC是SVN,\b并且用到的也只是简单的几个命令，昨天我学习了一下Github的一些操作，\b  觉得很有必要学习一个git了，这对我理解Github的用法也很有帮助，也对我以后有好处。于是我今天从Coursera上注册了一个课程，准备跟随他学习一下Git，笔记将记录在这里.\n\n## 常用命令\n\ngit rest --hard 是清除工作区和暂存区里面的代码，也就是清除当前未 add，和已经 add 但是没有 commit 的代码\ngit mv readme readme.md git 重命名的简便方式\ngit log -n4 --oneline 最近的 4 次\ngit log --master --graph 图例化\ngit help --web log \ngit config --local user.name 'wenzhe'\ngitk -all 图形界面\ngit checkout -b newBranch 创建新分支并切换到\ngit diff 比较两个commit 版本\ngit diff HEAD HEAD^\ngit branch -d branch 删除分支，如果没有合并 git 会提示，此时再 -D 删除最保险\ngit commit --amend\ngit rebase -i 父亲的commitid，来修改一个commit 或者多个\n上面那个命令修改多个的时候可能不能直接行，那就 git rebase --continue\ngit diff --cached 暂存区和 head 指向的 commit 之间的差别\ngit diff 工作区和暂存区的差别，后面可以加文件名详细的比较文件\n\ngit reset HEAD 暂存区的都不要了，还原回工作区\n变化工作区用 checkout 变暂存区用reset\ngit checkout -- index.html 把工作区的文件改为和暂存区一样的\n\n\n## 宏观的理解Git\n\n- continuous improvement by commits\n- simultaneous(同时) stability and development by branches\n- improved quality by pull requests\n- git都是以git开头，然后后面接空格\n- ![屏幕快照 2018-08-24 上午9.58.01.png](https://i.loli.net/2018/08/24/5b7f664156b51.png)\n\n## 一些不知道但是有用的命令\n\n- git --version 查看版本\n- git help init 查看所有的帮助\n- git config --global user.name\n- git log --oneline -number 输出log只一行 number为指定数量\n\n## 概念\n\n- working tree包含了项目的一次commit的文件、目录\n- staging area 通过add添加到里面\n- local resposition包含了本地的多次commit\n- staging area local在.git这个文件夹里\n- remote repository在远程\n- git status是查看的work tree 和staging area之间状态\n- git add add untracked and modify to staging area\n- git commit create snapshot of current project\n- git clone 得到local repository，可以指定名字在第二个参数\n- git remove -v\n- git push [-u] [rep] [branch]\n- git push -u origin master 如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push\n\n## git 的 DAG 模型\n\n- commit object - a small text file\n- Annotaed tag - 特定 commit 的索引\n- `git log --oneline --graph` 很好用\n- Git IDs 是一个 40 位的 16 进制数，也是 git Object 的名字，Git IDs 通常是四个字母的缩写或者更多的缩写\n- git show to show all ids\n- git hash-object get file's hash id \n- acyclic means no cyclesj\n\n## git branches\n\nmaster 指向该分支最近的一次提交，head 指向 master\nhead 指向当前的分支\n~ 指向上一次提交\n~~ 上一次的上一次\n^1 first parent of the commit \n^2 second parent of merge commit (比如在 a 节点分出 b 和 c， b&c -> d 在d 运行 ^2 就是c)\n^^ first parent's first parent\n\n每个 branch 构成了一个项目，commit 属于一个 branch\ngit branch 列出所有项目\ngit branch freatureX create branch\ngit checkout freatureX -> change branch\ngit branch -b newBranch create and change to newBranch\ngit 如果指向某个 commit，并想回到它工作，那就要创建一个新的分支继续\ngit branch -d featureX delete branch\n\nmerge: \n  - git checkout master git merge featureX git branch -d featureX\n\n\n\n\n","tags":["git"]},{"title":"如何写一个脚本","url":"/passages/如何写一个脚本/","content":"\n## 什么是脚本\n\n我们在 terminal 运行的 cd，ls，clear 这些都是脚本。\n\n由于进入目录、列表目录、清空控制台这些需求比较常见，所以系统为我们预设了这些脚本。\n\n## 用途\n\n脚本的功能很强大，可以帮我们做一些机械的工作。只是预设的脚本功能比较有限，\n但不必失望，我们可以通过自己动手写一些自定义脚本来丰富它，并且，它很简单。\n\n## 示例\n\n我们通过示例来说明如何写一个脚本。\n\n接下来实现的功能是这样的：我想只输入 `new hello` 就能帮我建一个 hello.html，并且每个 html 写入固定的模板。\n\n我把脚本都放到了本地 「~/scripts」 文件夹里面。\n\n\n1. 新建文件 「new」，同时新建一个 「index.html」，在 「index.html」 里面写入任意内容\n\n2. 打开 「new」，并写入以下内容\n\n```shell\nif [ -d $1.html ]; then\n    echo 'error: file exists'\n    exit\nfi\ntouch $1.html\ncp ~/documents/repos/scripts/index.html $1.html\necho 'successfully created'\nexit\n```\n\n3. 保存退出，并添加权限 `chmod +x new`\n\n4. 在 「~/.bashrc」 文件夹的最后添加这个脚本的路径，比如我的路径是：\n\n     `export PATH=\"/Users/mac/documents/repos/scripts/:$PATH\"`\n\n5. 执行 `source ~/.bashrc`\n\n6. 执行 `new hello`\n\n7. 恭喜你，完成了。\n\n## 总结\n\n实践往往是理解一个事物最快的方式，希望上面的可以帮助到你。\n\n如果你还想了解其他的例子，请点击[click](https://github.com/mysteryven/blog/blob/master/Notes/note-3.md)\n\n","tags":["技巧"]},{"title":"你所不知道的计算机技巧","url":"/passages/你所不知道的计算机技巧/","content":"\n# Linux 篇\n\n## linux 程序后台运行与关闭（以 anywhere 为例）\n\n### 下载\n\n`yarn global add anywhere`\n\n### 命令\n\n```shell\nanywhere& # 后台运行\njobs      # 查看当时哪些在后台运行\nfg        # 切换回后台命令\nctrl + c  # 关闭\nctrl + a  # 回到一个命令的开始\nctrl + e  # 回到末尾\n!$        # 代指上一次命令的最后一个字符串\nsudo !!   # 忘记加sudo，可以用这个命令重新执行\n!xxx      # 重新执行上一次这命令，比如 !vi 执行最近的一次 vi， !cd 执行最近的一次 cd\ncd -      # 最近的两次 cd 目录切换\nesc + .   # 把上一次最后一个参数打下来\n!!:gs/old/new # 替换上一条命令的 old 为 new\n> hi.html # 快速创建文件\nman ascii # 快速查看 ascii\n```\n\n## tree 忽略不想被展示的文件夹\n\n`tree -I [dir_name]`\n\n## 本地文件传到服务器\n\n`rz`\n\n## 服务器文件下载到本地\n  \n比如我想下载 user 文件夹到本地\n\n```\ntar -cvf  user.tar user/  # compress  \nsz # download\n```\n完成之后就可以去你的电脑里面寻找一下了，它的文件名是 「user.tar」\n\n\n## svn display special user's commits\n\n`svn log | sed -n '/USERNAME/,/-----$/ p' `\n\n\n## svn back to special revision\n\n`svn merge -rHEAD:9`\n\n\n\n\n# Vim 篇\n\n`>G` 增加此行到文档末尾的缩进层级\n\n# VPN 篇\n\n## shadowsocks (目前在用）\nhttps://shadowsocks.nu/\n\n## 蓝灯 （很垃圾，估计以后不会用了）\nhttps://github.com/getlantern/lantern\n\n## 云梯\nhttps://www.yuntipub.com/\n\n## 影梭\nhttps://i.ssvpn.me/blog/id=6\n\n## 枫叶主机\nhttps://www.fyzhuji.com/shadow.html\n\n## 佛跳墙\nhttps://i.ssvpn.me/\n","tags":["技巧"]},{"title":"使用vue-cli来构建单页面应用或多页面应用","url":"/passages/使用vue-cli来构建单页面应用或多页面应用/","content":"\n# 单页面应用配置\n\n## 安装 vue-cli\n\n```shell\nyarn global add @vue/cli\n\nyarn global add @vue/cli-service-global\n```\n\n## 初始化项目\n\n`vue create hello-world`\n\n## 运行项目\n\n```\nyarn serve\nyarn build\n```\n\n## 配置\n\n如果我如下配置，当我运行 `yarn build` ，我将在项目的根目录下得到一个 dist1 文件夹，并且，我能在此目录下打开 test.html 而不会发现找不到 css、js 链接的情况。\n\n原因在于我使用了 ./ 的 baseUrl。当然，我也可以使用 /dist1/。\n\n```js\n# vue.config.js\nmodule.exports = {\n  baseUrl: './',\n  outputDir: 'dist1',\n  indexPath: 'test.html'\n}\n```\n\n# 多页面应用配置\n\n接着上面单页面的配置，我们来进行多页面应用的配置。\n\n在 vue-cli 2 的时候，配置好像还蛮麻烦的，只是我没有配置过。我在配置 vue-cli 3 的时候感觉很简单，我们几乎不需要什么操作，基本目录结构和配置文件如下所示：\n\n```\nhello-vue\n  src\n    assets\n    components\n    footer\n      footer.html\n      footer.js\n    index\n      index.html\n      index.js\n  ...\n  dist\n```\n\n```js\n# vue.config.js\n\nconst baseUrl = '/dist/'\nmodule.exports = {\n  baseUrl: baseUrl,\n  runtimeCompiler: true,\n  pages: {\n    index: {\n    entry: 'src/index/index.js',\n    template: 'src/index/index.html',\n    filename: 'index.html',\n    title: 'Index page',\n    },\n    footer: {\n      entry: 'src/footer/footer.js',\n      template: 'src/footer.html',\n      filename: 'footer.html',\n      title: 'footer page',\n    }\n  },\n  devServer: {\n    historyApiFallback: {\n      proxy: 'http://localhost:8080/dist'\n    }\n  }\n}\n```\n\n需要注意的一点就是「devServe」。\n\n我的 baseUrl 是 dist 目录，并且 *.html 也是 dist 的直接子目录， 所以可以直接这样写。这样写了之后我就能在这些页面之间跳转了。\n\n在网上，我还看到了另外一个人的 devServer 的做法，原理是一样的，都是因为如果不设置 devServer 的话，浏览器就没有返回的东西。\n\n```\ndevServer: {\n  historyApiFallback: {\n  rewrites: [\n  { from: /\\/index/, to: '/index.html' },\n  { from: /\\/footer/, to: '/footer.html' }\n  ]\n  }\n}\n```\n\n## alias \n\n这一项可以使我们引入文件变得很方便，值得记录，放在最后\n\n```\n # vue.config.js\n configureWebpack: {\n    resolve: {\n      alias: {\n        'assets': '@/assets',\n        'components': '@/components',\n        'css': '@/modules/css',\n      }\n    }\n  },\n```\n\n使用的话，比如 src/main.js 想引用 modules/css/common.css，则只需\n\n`import css/common.css`\n\n写到这里，关于 vue-cli 的使用已经基本介绍完毕了，后续可能会补充一些小的细节吧！\n\n（完）\n\n","tags":["vue"]},{"title":"css笔记之宽度与高度","url":"/passages/宽度和高度/","content":"\n## 总结\n\n如何在写 css 的时候不要固定死 width、height。\n\n字体的默认行高是有字体设计师写的，所以才会出现不同字体 div 不一样高的情形。\n\n「font-size」 不影响 div 的高度，「line-height」 影响。\n\n1em 等于两个英文字符，一个汉字。\n\n如果一个单词很长，超越了容器的宽度，默认是不会换行的，除非加连字符或者 「word-break」， div 的宽度不是有字体长度决定的，span 的宽度是由字体长度决定的 span（内联元素）的上下 padding margin 都不影响div的高度。\n\n文档流中，内联元素从左到右，超出之后另起一行，块级元素每次都另起一行。\n\ndiv 的高度是由它内部文档流中元素的总和决定的。\n\n脱离文档流之后，div 的高度将不计入它。\n\n使用上下 padding 相等来使 div 垂直居中\n\n## 汉字对齐\n\n```html \n<span>姓名</span><br>\n<span>联系方式</span>\n```\n\n```css\nspan {\n  width: 4em;\n  text-align:justify;\n  display: inline-block;\n  border: 1px solid black;\n  overflow: hidden;\n  height: 24px;\n  line-height: 24px;\n}\nspan::after {\n  content: '';\n  display: inline-block;\n  width: 100%;\n}\n```\n\n## 超出隐藏\n\n搜索关键词 `css multi line text ellipsis`\n\n## 文字垂直居中 \n\n```css\nspan {\n  line-height: 24px;\n  padding: 8px 0px;\n}\n```\n\n## margin 合并\n\n如果父元素没有 border、 padding 来挡住子元素的 margin ，会使父子上下 margin 合并。\n\n##  实现 1:1 的 div\n\n`padding-top: 100%`\n\n(完)\n","tags":["css"]},{"title":"人工智能未必可怕","url":"/passages/人工智能未必可怕/","content":"\n之前有一段时间我相信这样一个观点：有朝一日，计算机会控制人类。今天我看了吴军的几篇文章，我明白过来了，原来这是不可能的。\n\n这个事情也让我知道了认知低有多恐怖，认知低的人永远看不到外面的世界，这是我一直很怕的事情，我一直非常想的一件事情就是：我要活明白，不要浑浑噩噩的。\n\n首先我想简单说明一下吴军的观点，他认为，由于电子计算机的极限所在，所以人工智能永远无法企及人类思维的高度，电子的运动等价于机械运动，而人的意识是不定的。 类比通俗一点的知识的话，就相当于永动机是不可能的一样，机器的制造也总有一个极限，这是建立在缜密的数学推理上的，人类永远无法超越这个极限的。 更多的，他认为，世界上的问题太多了，而人工智能能解决的问题却非常少，所以我们还不应该担忧人工智能未来的危害，而应该想如何使用它。\n\n我很支持他的观点，毕竟一方面来讲，还没了解就怕纯粹是懦夫的行为！另一方的这个潮流也不是我一己之力可以改变的，我做的只是如何在其中活的很好，之后再去思考如果改变的问题，毕竟我的境界还没达到，怎能断定这个方向是对人类好还是坏呢？\n\n我今天还知道了一个很棒的观点，吴军提倡一种思维，先宏观的考虑事物的极限，再来考虑如何实现，具体方法是什么。这是图灵的思考模式，非常值得我借鉴。如果我用这个观点，应该可以让我辨明很多空虚、不切实际的猜想，毕竟人的感觉很有限呢，在事情上，我们应该相信缜密的推理。\n\n呼呼呼，今天早上晚起了几分钟就没赶上车，折腾了半天坐的地铁还是迟到了，晚上回来去做了一个发型。回来路上在我后面的那个女生超级漂亮，我提前下车，偷偷的看她，哇，她的手好漂亮好漂亮，并且头发超级干净，想让她做我女朋友怎么办？ :)\n\n（完）\n\n"},{"title":"什么是路由","url":"/passages/什么是路由/","content":"\n## 什么是路由\n\n根据路径展示给用户不同的页面就是路由，表现在后端方面的话，就是比如我们请求`www.mysteryven.com/page1`， 后端返回给我们`page1`所对应的页面，当我们请求`www.mysteryven.com/page2`，后端返回给我们`page2`对应的页面，在前端方面展示的话，可能就类似于切换tab的形式。通过用户的操作来展示给用户不同的『界面』,更通俗的讲，就是我们根据用户的点击来切换UI！我也没就这么简单。\n\n## 路由的作用\n\n通过对路由的巧妙使用，我们能实现无刷新『切换页面』，非常方便我们构建单页面应用！好吧，其实是假的切换页面，另外呢还有一个功能，就是可以保存页面当前的状态然后分享出去，对方打开依然还保持着页面的状态。\n\n## 原理\n\n我们先来模拟一下`vue-router`的原理。\n\n代码请看下面链接\n\n--> [link](https://mysterywz.xyz/Assignments/jquery-router/)\n\n这里说明一下，这样的展示效果是没有实现刷新依然保存的那种效果，因为那个需要后端的配合，如果想和后端配合，也很简单，只需要在请求这几个路径时，让后端返回给你相同的页面就行了，具体页面的展示逻辑，需要我们前端来做。\n\n比如说我们可以写Node.js的一小段路由的代码：\n\n```js\n    if (path === '/' || '/tab1' || 'tab1') {\n        let string = fs.readFileSync(./index.html)  \n        response.statusCode = 200 \n        response.setHeader('Content-Type', 'text/html; charset=utf-8')\n        response.write(string)\n        response.end()\n    }\n```\n\n如果只由前端来实现路由的效果的话，我们可以使用锚点的方法来代替。代码请点击下方链接\n\n--> [link](https://mysterywz.xyz/Assignments/anchor-router/)\n\n这个我认为也是vue的原理，我故意的把锚点的链接都弄的和vue的一致。\n\n----\n\n今天有点晚了，明天我看了`vue-router`再来写后半部分\n\n现在已经是第二天了，我今天去看牙医，回来弹了一个小时琴就快11点了，现在来写这篇博客。\n\n我发现用了vue之后上面的问题直接解决了，还要什么后端配合嘛？并且超级简单的代码，原来这就是传说中的单页面应用，以前我觉得神乎其神，现在就是也就这样嘛。\n我的vue版本代码也做完了，但是基本是copy的官方版本，毕竟是个简单的demo嘛，下一步把vue在看一遍，接着写完那个vue的第一个毕设。\n\n-->[link](https://mysterywz.xyz/Assignments/vue-router/)\n\n(完)","tags":["js"]},{"title":"解释EventHub机制","url":"/passages/how-to-understand-eventhub/","content":"\n## 前言\n\n在项目中，我们可能会需要两个模块间相互通讯，这时候就需要用到EventHub来处理这个问题.举个例子来说，我们页面的头和内容分别是用两个js文件来写的，这时候如果你想通过点击内容来触发头文件的事件，此时就需要用到eventHub机制。\n\n\n## 代码实现\n\n```\n// eventHub.js\nwindow.eventHub = {\n  fnList: [],\n  on(name, callback) {\n    if (!this.fnList[name]) {\n      this.fnList[name] = []\n    }\n    this.fnList[name].push(callback)\n  },\n  emit(name, data) {\n    this.fnList[name].map((fn)=>{\n      fn.call(undefined, data)\n    })\n  }\n}\n```\n\n## 举例子来说明\n\n> 我们想实现的功能是这样的: 在点击按钮来让header的数字加1  \n\n\n```\n// index.html\n <header>\n    数字:<span id='number'>1</span>\n  </header>\n  <main>\n    <button onclick='mainJs.addOne()'>加1</button>\n  </main>  \n\n\n\n/* js 部分 */\n// 我们就这样来假装两个文件了 \nvar headerJs = {\n  run() {\n    window.eventHub.on('addOne', (number)=>{\n      document.getElementById('number').innerHTML = number\n    })\n  }\n\n}\nheaderJs.run()\n\n\nvar mainJs = {\n  num: 1,\n  addOne() {\n    window.eventHub.emit('addOne', this.num++)\n  }\n}\n```\n\n<img src='https://i.loli.net/2018/08/17/5b7624f902c78.png'>\n\n我疯狂加了15次 结果就如上图所示。\n\n## 在vue中的应用\n\n> vue中直接替我们写好了on和emit函数，使用方法是类似的，同样的我们在例子中来理解这个过程。\n\n首先，我们知道组件内部的input的值单单使用v-model的双向绑定无法直接传到外部，此时我们就需要一些tricks。即用eventhub和监听组件内部的input输入事件来解决，具体如下。\n\n<script async src=\"//jsfiddle.net/0z8gnpv1/17/embed/\"></script>\n\n我试用了一下jsfiddle的分享功能，但是浏览的时候由于网速的关系吧，可能不是很理想，所以再paste源码到这\n\n\n\n```\n <div id='app'>\n    内部:<editable-span v-on:updata='updataName' v-bind:name='name'></editable-span> \n    <hr>\n   外部:{{name}}\n  </div>\n   <script src=\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js\"></script>\n```\n\n\n \n```\nVue.component('editable-span', {\n\tprops: ['name'],\n\ttemplate: `\n  \t<input :value=\"name\" @input=\"updataName\">`,\n  methods: {\n  \tupdataName(e){\n    \tthis.$emit('updata', e.currentTarget.value)\n    }\n  }\n    \n})\n\nnew Vue({\n\tel: '#app',\n  data: {\n  \tname: ''\n  },\n  methods: {\n  \tupdataName(e) {\n    \tthis.name = e\n    }\n  }\n})\n```\n\n效果\n<img src='https://i.loli.net/2018/08/17/5b763aef6f9b8.png'>\n\n(完)\n","tags":["js"]},{"title":"关于form表单的一些事情","url":"/passages/理解form表单/","content":"\n我一直不敢用form表单，总觉得对它有种不熟悉的感觉，但是当我写登录注册页面的时候，觉得用form表单才是正道，因为我用div写连回车\n触发登录的功能都没有，所以我就专门学习了一下form，现在对它也不在畏惧了，以下是我整理的几条：\n\n## 监听form表单的事件\n\n正确的做法是设置button的type为submit，并监听form表单的submit事件，这样我们回车也能触发submit事件。  \n如果button的type是其他的那么就不会触发submit了，但是不填type默认也是submit\n\n```\n <form @submit=\"test\">\n    <h3>注册</h3>\n    <svg class=\"icon close\" aria-hidden=\"true\" @click=\"registerVisible = false\">\n        <use xlink:href=\"#icon-close\"></use\n    </svg>\n    <div class=\"row\">\n        <label for=\"\">邮箱</label>\n        <input type=\"text\">\n    </div>\n    <div class=\"row\">\n        <label for=\"\">密码</label>\n        <input type=\"text\">\n    </div>\n    <div class=\"actions\">\n        <button type='submit'>注册</button>\n        <button>注册</button>\n    </div>\n</form>\n```\n\n## 要设置阻止默认事件\n\n要在test函数里面写preventDefault，不然的话会执行form的默认事件，这样就刷新页面了。以前人们会利用form可以发请求的功能来实现类似jsonp的功能，现在一般都用script来做。\n\n```\ntest(e) {\n    e.preventDefault()\n    console.log('run test')\n}\n```\n\nvue文档推荐把事件修饰符写在\bhtml，这样就能保持js不操作Dom\n\n\n## 阻止冒泡事件\n\n我\b以前会把阻止默认事件和这个弄混，这个是不让事件继续传播了，和那个根本不是一个东西\n`e.stopPagination`\n\n(完)\n","tags":["js"]},{"title":"自己实现jQuery","url":"/passages/JQuery实现思路小结/","content":"\n> 本篇博文来简单的介绍一下jQuery的实现思路\n\n首先我们要明确我们的目的: Dom根本没法用啊, 很多API根本就是摆设,起不到任何作用,\n所以于是就想基于Dom写一个好用的库,来提高前端的效率.Jquery就产生了,他依然还是用Dom来操作,\n只不过可能我们用jQuery写一句代码,jQuery自己的那个函数要执行十句.总之,jQuery比Dom好用非常多\n\n## 实现过程\n\n##  封装一个函数\n以给节点添加class为例\nDom的话\n```\nvar id = document.getElementById('xxx');\nid.classList.add('red');\n多个的话要一个个的添加\n```\n发现了不好的地方,我们就要来改进了 \n自己实现: \n````\nfunction addClass(node, classes) {\n  for (key in classes) {\n    let method = classes[key] ? 'add':'remove';\n    node.classList[method](key);\n  }\n}\nvar xx = document.getElementById('item1');\naddClass(xx, {  red: true});\n这样我们可以使用addClass,添加多个类,只需给addClass的第二个参数加值就可以了\n```\n\n但是上面那样还是不太好 \n\n## 命名空间\n我们可能写很多代码,别人怎么知道这是谁写的,怎么才能不和别人的重复\n```\nvar dom = {};\ndom.addClass = function (node, classes) {\n  for (key in classes) {\n    let method = classes[key] ? 'add':'remove';\n    node.classList[method](key);\n  }\n}\n```\n\n这样算还可以了,但是我们想更方便,我们为什么还要记录一个命名空间的名字,我们想直接xx.addClass,这样多好\n\n### 能不能把node放到前面\n1. 扩展node接口\n```\nNode.prototype.addClass = function ........\n```\n这样可以是可以,但是人人都添加的话,那岂不是乱套了?\n所以我们总和命名空间和扩展prototype方法的优点和思路,如下:\n\n2. 我们写一个函数 Node2 \n```\nfunction Node2(node) {\n  return {\n    element: node,\n    addClass: function (classes) {\n        for (key in classes) {\n        let method = classes[key] ? 'add' : 'remove';\n        node.classList[method](key);\n      }\n    }\n  }\n}\n\n// 之后我们可以这样调用了\nvar xx = document.getElementById('item1');\nvar node = Node(xx);\nnode.addClass({red:false})\nxx.addClass({red: true})\n\n```\n\n- 给他改一下名字 叫做jQuery就是我们的jQuery啦\n```\nwindow.jQuery = Node2\n```\n- 或者给个简写\n```\nwindow.$ = jQuery \n```\n\n### 改进\n\n当然JQuery没有我们上面那个方法那么笨, 他还接受选择器,可以操作多个节点,所以我们要改进一下我们的代码\n当然思路还是一样的\n我们需要改进什么呢? \n1. 去掉getElementById\n2. 操作多个node\n3. 添加text函数 获得text命令\n\n```\nfunction jQuery (nodeOrSelector) {\n  let nodes = {};\n  if (typeof nodeOrSelector === 'string') {\n    let temp = document.querySelectorAll(nodeOrSelector);\n    for (let i = 0; i < temp.length; i++) {\n      nodes[i] = temp[i];\n    }\n    nodes.length = temp.length;\n  } else(nodes instanceof Node) {\n    nodes = {0: nodeOrSelector, length: 1};\n  }\n  \n  nodes.addClass = function(classes) {\n    for (key in classes) {\n      console.log(2)\n      let method = classes[key] ? 'add':'remove';\n      console.log(nodes.length)\n      for (let i = 0; i < nodes.length; i++) {\n        console.log(key);\n        nodes[i].classList[method](key);\n      }\n    }\n  }\n  nodes.text = function(text) {\n\n    if (text === undefined) {\n      let content = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        content.push(nodes[i].textContent);\n      }\n      return content;\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        nodes[i].textContent = text;\n      }\n    }\n  }\n  return nodes\n}\n\nvar lis = jQuery('ul>li');\nlis.addClass({red:true})\n\n```\n\n\n### 总结\n\n好了! 经过一步步的改进我们已经很接近jQuery的实现原理了,我们是直接把函数放到JQuery里面\n而jQuery是放到prototype里面,我们等以后再更新jQuery!其实到这里就已经很清晰啦,已经明白jQuery实现的原理了!\n","tags":["jQuery"]},{"title":"有点绕的prototype","url":"/passages/prototype讲解/","content":"\n学习JS的原型链有一个公式,记住这个公式,就可以\n理清所有的变化了 \n\n> var 对象 = new 函数() \n则 对象的__proto__ === 函数的prototype\n\n\n关键点还是看`构造这个对象的是什么`\n\n\n---- \n下面举例:\n\n```\nvar o = new Object()\na.__proto__ == Object.prototype\n\nvar a = new Array(1)\na.__proto__ = Array.prototype\n\n由于Array是一个函数是由Function构造的,所以\nArray.__proto__ == Function.prototype\n\nObject 也是一个函数\nObject.__proto__ == Function.prototype\n\nFunction是一个函数\nFunction.__proto__ == Function.prototype\n\nFunction.prototype 是一个对象,处于顶端了\nFunction.prototype.__proto__ == Object.prototype\n\nObject.__proto__ === Function.prototype\n\n```\n","tags":["js"]},{"title":"flex实现几种常用的布局","url":"/passages/flex常用布局/","content":"\n## 目录\n1. 手机布局\n2. 九宫格布局 \n3. 双飞翼\n4. 完美居中\n\n\n<!--more-->\n\n\n### 手机布局\n<div>\n<img src='https://i.loli.net/2018/03/26/5ab8b52083b73.png'\n    width=\"300px\" height='500px'\n>\n</div>\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    ul, li {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n}\nheader {\n  height: 100px;\n  background: black;\n}\nfooter {\n  height: 100px;\n}\nmain {\n  flex-grow: 1\n}\nfooter ul {\n  display: flex;\n  justify-content: space-between;\n  height: 100px;\n}\nli {\n   background: #efefef;\n   border: 1px solid black;\n   width: 25%;\n   height: 100%;\n}\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header></header>\n    <main></main>\n    <footer>\n      <ul>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n      </ul>\n    </footer>\n  </div>\n</body>\n</html>\n\n```\n\n### 2. 九宫格布局\n\n<div>\n<img src='https://i.loli.net/2018/03/26/5ab8b88b35039.png'\n    width=\"300px\" height='500px'\n>\n</div>\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    .parent{\n      width: 300px;\n      border: 3px solid red;\n      display: flex;\n      flex-wrap: wrap;\n      justify-content: space-between\n    }\n    child {\n      width: 90px;\n      height: 90px;\n      border: 1px solid black;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"parent\">\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n    <child></child>\n  </div>\n</body>\n</html>\n```\n### 双飞翼\n\n<div>\n<img src='https://i.loli.net/2018/03/26/5ab8d4ce37368.png'\n    width=\"300px\" height='500px'\n>\n</div>\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    .parent {\n      display: flex;\n\n    }\n    .child1 {\n      width: 100px;\n      height: 100px;\n      background: green;\n      order: 3;\n    }\n    .child2 {\n      width: 200px;\n      height: 100px;\n      order: 2;\n    }\n    .child3 {\n      height: 100px;\n      width: 100px;\n      background: green;\n      order: 1;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"parent\">\n    <div class=\"child1\">1</div>\n    <div class=\"child2\">2</div>\n    <div class=\"child3\">3</div>\n  </div>\n</body>\n</html>\n```\n\n\n### 完美居中\n\n![Screen Shot 2018-03-26 at 7.14.43 PM.png](https://i.loli.net/2018/03/26/5ab8d636c8771.png)\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    .parent {\n      border: 1px solid red;\n      width: 300px;\n      height: 400px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"parent\">\n    <div class=\"child\">\n      I am wenzhe\n    </div>\n  </div>\n</body>\n</html>\n```\n","tags":["css"],"categories":["编程"]},{"title":"Echarts填坑","url":"/passages/ECharts使用总结/","content":"\n\n这三天，被一个流程图折磨的要命，刚开始用的是 HighLight，感觉文档很是晦涩难懂，后来换了【echarts】，用起来舒服多了。 \n但是也是遇到了几个地方，下面整理一下遇到的问题。\n\n<!-- more -->\n\n## 1. 异步更新数据\n异步更新数据就是当在ajax的函数里面取到数据之后，在` myChart.setOption({}）`里面添加时关于系列的数据就好了\n系列中，可以添加[data.x, data.y]的格式。\n\n## 2. 根据需求给点设置不同的颜色\nseries里面写的就是每个点，在series设置itemstyle属性即可，具体根据下面代码设置：\n\n```\nseries: [{\n\tname: '工序',\n\ttype: 'bar',\n\tdata: viewModel.processAndTime(),\n\titemStyle: {\n\t    normal: {\n            color: function(params) {\n            \tvar colorList = viewModel.colorList();\n            \treturn colorList[params.dataIndex];\n            }\n        }\n\t}\n```\n\n## 3. 散点图的形状\n设置symbol属性\n取值有triangle， diamond， circle等\n\n## 4. 在一副表中显示多个图\n在series里面添加对象即可\n\n## 5. 设置柱形图的宽度 间隔 圆角\n\n- barWidth\n- interval\n- 圆角\n\n```\nitemStyle: {\n\tnormal: {\n        barBorderRadius: 10\n    },\n\temphasis: {\t\n        barBorderRadius: 10\n    }\n},\n```\n\n\n## 6. 显示两个坐标轴\n比如，显示两个x轴，那就在xAxis下加两个对象，比如\n\n```\nxAxis: [\n\t{\t\n\t\tdata: data1\n\t\ttype: 'time'\n\t}\n\t{\n\t\ttype: 'category'\n\t\tdata: data2\n\t}\n]\n                            \n```\n\n之后你还要在series的添加类似于`xAxisIndex: 1`的数据,如果不使用添加的坐标轴，他会不显示。\n\n\n# 7 以时间为x轴的横道图(抄的别人的代码)\n```\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            background: #020202;\n            overflow: hidden;\n        }\n\n        #container {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n<div id=\"container\"></div>\n</body>\n<script src=\"https://cdn.bootcss.com/jquery/3.3.1/core.js\"></script>\n<script src=\"https://cdn.bootcss.com/echarts/4.0.4/echarts-en.common.js\"></script>\n<script>\n    //计算两个日期相差天数\n    function  DateDiff(sDate1,sDate2){    \n    //sDate1和sDate2是2006-12-18格式\n        var aDate,oDate1,oDate2,iDays;\n        aDate = sDate1.split(\"-\");\n        oDate1 = new Date(aDate[1]+'-'+aDate[2]+'-'+aDate[0]) ;   \n        aDate = sDate2.split(\"-\");\n        oDate2 = new Date(aDate[1]+'-'+aDate[2]+'-'+aDate[0]);\n        iDays = parseInt(Math.abs(oDate1-oDate2)/1000/60/60/24)    ;//把相差的毫秒数转换为天数\n        return iDays;\n    }\n\n    //获得两个日期间所有日期-fn1\n    Date.prototype.format = function() {\n        var s = '';\n        var mouth = (this.getMonth()+1)>=10?(this.getMonth()+1):('0'+(this.getMonth() + 1));\n        var day = this.getDate()>=10?this.getDate():('0'+this.getDate());\n        s += this.getFullYear()+'-'; // 获取年份。\n        s += mouth + \"-\"; // 获取月份。\n        s += day;   //获取日。\n        return (s); //返回日期。\n    };\n    //获得两个日期间所有日期-fn2\n    function getAll(begin, end) {\n        var return_=[];\n        var ab = begin.split(\"-\");\n        var ae = end.split(\"-\");\n        var db = new Date();\n        db.setUTCFullYear(ab[0], ab[1] - 1, ab[2]);\n        var de = new Date();\n        de.setUTCFullYear(ae[0], ae[1] - 1, ae[2]);\n        var unixDb = db.getTime();\n        var unixDe = de.getTime();\n        for (var k = unixDb; k <= unixDe;) {\n            return_.push((new Date(parseInt(k))).format());\n            k = k + 24 * 60 * 60 * 1000;\n        }\n        return return_;\n    }\n\n\n    var dataa = [\n        {\n        \"name\":\"项目a\",\n        \"startTime\":\"2017-08-06\",\n        \"latestTime\":\"2017-08-19\"\n        },\n        {\n        \"name\":\"项目b\",\n        \"startTime\":\"2017-08-14\",\n        \"latestTime\":\"2017-08-17\"\n        }\n    ];//假数据，实际应用可以用ajax从后台请求，获取数据\n    var start_=\"2017-08-01\",end_=\"2017-08-29\";//用户自定义时间\n    var data$ = DateDiff(start_,end_);//用户自定义的时间长度\n    var data1 = DateDiff(start_,dataa[0].startTime);//项目a 起始位置\n    var data1_1 = DateDiff(dataa[0].startTime,dataa[0].latestTime);//项目a 持续时间\n    var data2 = DateDiff(start_,dataa[1].startTime);//项目b 起始位置\n    var data2_1 = DateDiff(dataa[1].startTime,dataa[1].latestTime);//项目b 持续时间\n    x_ = getAll(start_,end_);\n\n    var myCharts =echarts.init(document.getElementById(\"container\"));\n    var option = {\n        tooltip: {\n            trigger: 'axis',\n            axisPointer: {            \n                type: 'shadow'      \n            },\n            formatter: function (params) {\n                console.log(params);\n                var tar = params[1];\n                return tar.name + '<br/>' + tar.seriesName + ' :::: ' + tar.value;\n            }\n        },\n        grid: {\n            left: '3%',\n            right: '4%',\n            bottom: '3%',\n            containLabel: true\n        },\n        xAxis: {\n            type: 'value',\n            max:data$,\n             axisLabel: {\n                 formatter: function (value, index) {\n                    console.log(value);\n                    return x_[value]\n                 }\n             }\n        },\n        yAxis: {\n            type: 'category',\n            splitLine: {show: false},\n            data: ['项目a', '项目b']\n        },\n        series: [\n            {\n                name: '辅助',\n                type: 'bar',\n                stack: '总量',\n                itemStyle: {\n                    normal: {\n                        barBorderColor: 'rgba(0,0,0,0)',\n                        color: 'rgba(0,0,0,0)'\n                    },\n                    emphasis: {\n                        barBorderColor: 'rgba(0,0,0,0)',\n                        color: 'rgba(0,0,0,0)'\n                    }\n                },\n                data: [data1,data2]\n            },\n            {\n                //每个项目 持续时间长度\n                name: '时长',\n                type: 'bar',\n                stack: '总量',\n                label: {\n                    normal: {\n                        show: true,\n                        position: 'inside'\n                    }\n                },\n                data: [data1_1,data2_1]\n            }\n        ]\n    };\n\n    myCharts.setOption(option);\n\n</script>\n</html>\n```","tags":["echarts"],"categories":["编程"]},{"title":"7 种常用的排序算法","url":"/passages/常用的排序算法/","content":"> 排序可视化请看[网站](https://visualgo.net/bn/sorting)\n\n自己总结了一下几个常用的排序算法，用 JS 实现的，有错误欢迎指出。\n\n## 目录\n- 冒泡排序\n- 桶排序\n- 计数排序\n- 插入排序\n- 选择排序\n- 堆排序(两种方法)\n- 基数排序\n\n<!--more-->\n\n\n## 算法\n\n### 通用部分\n \n```\n\nfunction exch(a, i, j) {\n\tvar temp = a[i];\n\ta[i] = a[j];\n\ta[j] = temp;\n}\n\n```\n### 冒泡排序\n\n```\n\nfunction bubbleSort(a) {\n\tvar len = a.length;\n\tif (len == 0) \n\t\treturn [];\n\n\tfor (var i = 0; i < len -1; i++) {\n\t\tfor (var j = i; j < len; j++) {\n\t\t\tif (a[j] > a[j+1])\n\t\t\t\texch(a, j, j+1);\n\t\t}\n\t}\n\treturn a;\n}\n\n```\n### 桶排序\n\n```\nfunction bucketSort(a) {\n\tvar len = a.length;\n\tif (len == 0) {\n\t\treturn []\n\t}\n\n\tvar res = [];\n\tvar bucket = [];\n\tvar i = 0,\n\t\tj = 0,\n\t\tmin = 0;\n\t\tmax = 0;\n\n\tfor (i = 0; i < len ; i++) {\n\t\tif (min > a[i])\n\t\t\tmin = a[i];\n\t\tif (max < a[i])\n\t\t\tmax = a[i];\n\t}\n\n\t//count of buckets  53 9\n\tvar count = Math.ceil((max - min) / 10);\n\n\tfor (i = 0; i < len; i++) {\n\t\tvar current = a[i];\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tif (current >= min + j*10 && current < min + (j+1)*10) {\n\t\t\t\tif (!bucket[j])\n\t\t\t\t\tbucket[j] = [];\n\t\t\t\tbucket[j].push(current);\n\t\t\t\tbucket[j] = insertSort(bucket[j]); \n\t\t\t\t//  对每个桶里的元素进行插入排序\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tfor (j = 0; j < bucket[i].length; j++) {\n\t\t\tres.push(bucket[i][j]);\n\t\t}\n\t}\n\n    return res;\n\n}\n\n```\n### 计数排序\n\n```\nfunction countSort(a) {\n\tvar len = a.length;\n\tif (len == 0) \n\t\treturn [];\n\n\tvar min = a[0];\n\tvar max = a[0];\n\tvar bucket = [];\n\tvar res = [];\n\n\tfor (let i = 1; i < len; i++) {\n\t\tif (min > a[i]) {\n\t\t\tmin = a[i];\n\t\t}\n\t\tif (max < a[i]) {\n\t\t\tmax = a[i];\n\t\t}\n\t}\n\n\tfor (let i = 0; i < len; i++) {\n\t\tlet index = a[i] - min;  // 为了防止第一个数很大的时候浪费空间，所以每次都从桶的0开始\n\t\tif (bucket[index] == undefined) {\n\t\t\tbucket[index] = 1;\n\t\t}\n\t\telse {\n\t\t\tbucket[index]++;\n\t\t}\n\t}\n\n\tfor (let i = 0; i < max-min+1; i++) {\n\t\tif (bucket[i] != undefined) {\n\t\t\tlet count = bucket[i]\n\t\t\twhile (count > 0) {\n\t\t\t\tres.push(i+min);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n```\n### 插入排序\n\n```\nfunction insertSort(a) {\n\tvar len = a.length;\n\tif (len == 0)\n\t\treturn [];\n\n\tvar i = 0,\n\t\tcurrent = 0;\n\n\tfor (i = 1; i < len; i++) {\n\t\tcurrent = i;\n\t\twhile (current >= 1 && a[current] < a[current-1]) {\n\t\t\texch(a, current, current-1);\n\t\t}\n\t}\n\n\treturn a;\n}\n```\n### 选择排序\n```\nfunction selectSort(a) {\n\tvar len = a.length;\n\tif (len == 0) {\n\t\treturn [];\n\t}\n\tvar minValue = a[0];\n\tvar minIndex = 0;\n\tvar i = 0,\n\t\tj = 0;\n\n\tfor (i = 0; i < a.length-1; i++) {\n\t\tminValue = a[i];\n\t\tminIndex = i;\n\t\tfor (j = i+1; j < a.length; j++) {\n\t\t\tif (minValue > a[j]) {\n\t\t\t\tminIndex = j;\n\t\t\t\tminValue = a[j];\n\t\t\t}\n\t\t}\n\t\texch(a, i, minIndex);\n\t}\n\treturn a;\n}\n\n```\n### 堆排序（数组第一个位置用不用分出两种方法）\n\n```\n//  数组第一个位置留空\nfunction heapSort(a) {\n\tlet N = a.length;\n\n\tfor (let k = Math.floor(N/2); k>= 1; k--) {\n\t\tsink(a, k, N);\n\t}\n\n\twhile(N > 1) {\n\t\texch(a, 1, N--);\n\t\tsink(a, 1, N);\n\t}\n\tconsole.log(a);\n\t\n}\n\nfunction sink(a, k, N) {\n\twhile (2 * k <= N) {\n\t\tvar j = 2 * k;\n\t\tif (j < N && a[j]<a[j+1])\n\t\t\tj++;\n\n\t\tif (a[k] > a[j])\n\t\t\tbreak;\n\t\texch(a, k, j);\n\t\tk = j;\n\t}\n}\n```\n\n```\n// 第一个位置不留空\nfunction heapSort(a) {\n\tlet N = a.length - 1;\n\n\tfor (let k = Math.ceil((N-1)/2); k>= 0; k--) {\n\t\tsink(a, k, N);\n\t}\n\n\twhile(N > 0) {\n\t\texch(a, 0, N--);\n\t\tsink(a, 0, N);\n\t}\n\tconsole.log(a);\n\t\n}\n\nfunction sink(a, k, N) {\n\twhile (2 * k + 1 <= N) {\n\t\tvar j = 2 * k + 1;\n\t\tif (j < N && a[j]<a[j+1])\n\t\t\tj++;\n\n\t\tif (a[k] > a[j])\n\t\t\tbreak;\n\t\texch(a, k, j);\n\t\tk = j;\n\t}\n}\n```\n\n### 基数排序\n\n```\nfunction radixSort(a) {\n\tvar len = a.length;\n\tif (len == 0) {\n\t\treturn [];\n\t}\n\n\tvar res = [];\n\tvar bucket = [];\n\tvar isBreak = false;\n\tvar count = 1;\n\n\twhile (!isBreak) {\n\t\tisBreak = true;\n\t\tbucket = [];  // 注意每次桶都要更新..因为这里我被困了好久\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar remain = Math.floor(a[i] / count) % 10;\n\t\t\tif (remain > 9)\n\t\t\t\tremain = 0;\n\t\t\tif (remain != 0) {\n\t\t\t\tisBreak = false;\n\t\t\t}\n\t\t\tif (!bucket[remain]) {\n\t\t\t\tbucket[remain] = [];\n\t\t\t}\n\t\t\tbucket[remain].push(a[i]);\n\t\t}\n\t\ta = [];   // 和桶一样每次要更新\n\t\tfor (var j = 0; j < bucket.length; j++) {\n\t\t\tif (Array.isArray(bucket[j]) ) {\n\t\t\t\tfor (var k = 0; k < bucket[j].length; k++) {\n\t\t\t\t\ta.push(bucket[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcount *= 10;\n\t}\n\n\treturn a;\n}\n```\n","tags":["algorithms"],"categories":["编程"]},{"title":"http-summary","url":"/passages/http总结/","content":"# 前端需要掌握的Http知识\n\n## 目录\n- 请求格式\n- 响应格式\n- 工具\n- 状态码\n\n<!--more-->\n\n## 请求格式\n\tget / Http1.1\n\tHost: www.mysterywz.xyz\n\tUser-Agent: \n\taccept: */*\n\tcontent-type: \n\n\tcontent\n\n## 响应格式\n\tHTTP1.1 200 ok\n\tkey-value\n\tcontent-type\n\tcontent-length\n\tserver\n\n\tcontent\n\n## 查看http请求和响应的工具\n1. curl命令  \n  curl -s -v -- www.baidu.com\n  \n2. chrome的network工具条 \n  network -- veiw source\n\n## 状态码\n1. 2--\n\t- 200 ok\n \t- 201 created\n\t- 202 accepted\n\t- 203 服务器是一个转换代理服务器\n\t- 204 成功处理 但是没返回内容\n2. 3--\n\t- 301 请求的资源被永久移动\n\t- 302 临时重定向\n\t- 303对应的请对在另外一个url找到\n\n3. [剩下的](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)\n\n\n\n\n\n\n\n\n","tags":["Http"],"categories":["编程"]},{"title":"A大调单簧管协奏曲","url":"/passages/分享一首莫扎特的曲子/","content":"  A大调单簧管协奏曲是莫扎特一首非常有名的曲子。 \n <!--more-->\n  莫扎特一生创作了600多首曲子，但是只创作了两首单簧管协奏曲，足见此曲的珍贵。莫扎特十分喜欢单簧管的音色，莫扎特本人也是很擅长单簧管的。  \n\n  此曲是他送给好友斯塔德勒的，莫扎特和斯塔德勒关系是相当的好，他俩是酒友的关系，经常在一块喝酒。在首演的时候，莫扎特很重视，甚至亲自担任第一小提琴手，为斯塔德勒伴奏～  \n\n  莫扎特本人有点不拘小格哈哈哈，说直接一点，就是生活很不条理吧，因为这个缘故，莫扎特很多作品都丢了，很可惜。当时这首曲子也丢了! 很多年之后才又被发现，如何发现的呢？我们要感谢莫扎特的妻子。  \n\n  莫扎特虽然很有才，但是他的妻子却一点都不珍惜，对他态度也非常不好，莫扎特甚至还写过一部歌剧来表达他妻子对他的态度～. \n\n  但是他妻子很擅长理财，她懂得莫扎特作品的价值，莫扎特去世之后，她问莫扎特的朋友，莫扎特有没有很好的作品找不到了，她想大赚一笔。有人就说这首A大调单簧管协奏曲很好听 但是丢掉了，后来在她妻子和莫扎特朋友的寻找下, 终于找到了，原来这首曲子被一位意大利的单簧管作曲家雪藏了，他想据为己有! 等过几年，大家都忘记了莫扎特的那首曲子了，再出版。那个时代，去世的作曲家的作品是不会被演奏的，我们现在觉得很不可思议，但当时确实是这样的。万幸啊，没被这位小人得手。  \n  \n  此曲很少在国内演出，本人非常幸运，几天前得以观赏，虽然规模不大，只有单簧管加两个小提琴和一个中提琴还有一个大提琴，但是已经很满足了!当时虽然我买了后面的票，但是因为人很少，工作人员让我坐到了第11排，得以更近的欣赏哈哈，另外一点，这个小型乐团的第一小提琴手超级漂亮哈哈哈。对于莫扎特，很可惜，35岁就去世了，并且现在他在维也纳的墓地都只是一个空墓，老天总是嫉妒英才。\n最后，在这里贴一个我上传到b站的视频，很精彩。\n\n\n","tags":["Mozart"],"categories":["音乐"]},{"title":"Hello My Blog","url":"/passages/hello-world/","content":"\n我是从大一的时候开始写日记的，四五年下来，让我慢慢习惯上了「写作」。它可以把我的知识大脑中下载下来，供我以后查阅；也可以记录我的生活。\n\n我也一直很喜欢写作，甚至，我曾想当一名作家。后来一想，太不现实了，我能写出个球...... \n\n但是现在也算变相实现了吧，我成了一名程序员，有了自己的博客。虽然应该没人喜欢、没人会看我的博文，但是，我对我的内容是自信的，我写出来的东西都是我目前认为对我很重要也很值得记录的东西。\n\n我一直憧憬能成为很厉害的人，包括技术，思想，艺术。不管可不可以，这个博客都将记录我的学习历程，我会好好经营它的。\n\n未来一到两年，我博客的主要内容应该是以技术、读书笔记这两块为主。可能会有一点延伸，就看自己学习的情况了！\n\n感悟的话，不应该留在现在说，要留到有了一定成绩之后再说，这个开篇就到这儿吧。\n\n（完）\n\n"}]